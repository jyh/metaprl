(*
 * The M Abstract Syntax.
 *
 * ----------------------------------------------------------------
 * Copyright (C) 2003 Adam Granicz, Caltech
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; either version 2
 * of the License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
 *
 * Author: Adam Granicz
 * Email: granicz@cs.caltech.edu
 *)

Module M_ast

// Define the term-set to be used.

Terms -extend "M_ast" {
   // Arithmetic operators
   declare AddOp
   declare SubOp
   declare MulOp
   declare DivOp

   // Relational operators
   declare LeOp
   declare LtOp
   declare GeOp
   declare GtOp
   declare EqOp
   declare NeqOp

   // Simple expressions.
   declare TrueExpr
   declare FalseExpr
   declare IntExpr[n]
   declare BinopExpr{'op; 'e1; 'e2}
   declare RelopExpr{'op; 'e1; 'e2}
   declare VarExpr{'v}
   declare LambdaExpr{'e}

   // If
   declare IfExpr{'e1; 'e2; 'e3}

   // Subscripting
   declare SubscriptExpr{'e1; 'e2}

   // Assignment
   declare AssignExpr{'e1; 'e2; 'e3}

   // Sequencing
   declare SeqExpr{'e1; 'e2}

   // Function arguments
   declare ArgNil
   declare ArgCons{'a; 'rest}

   // Function calls and return
   declare ApplyExpr{'f; 'args}

   // Let-definition
   declare LetVarExpr{'e1 ;'e2}

   // Tuples
   // TEMP: this are not used yet.
   declare Length[n]
   declare AllocTupleNil
   declare AllocTupleCons{'a; 'rest}
   declare LetTuple{'length; 'tuple; 'e}

   // Mutually recursive functions
   declare LetRec{'e1; 'e2}
   declare Fields{'fields}
   declare Label[t]
   declare FunDef{'label; 'exp; 'rest}
   declare EndDef

   // Function projection
   declare LetFun{'R; 'label; 'rest}
}

// These terms must be eliminated by the end of the
// informal post-parsing rewrites.

Terms -extend "$" {
   declare number[n]
   declare SimpleFun{'f; 'params; 'body}
   declare Functions{'fvars; 'pbunch; 'fbodies}
   declare NewFun{'fun; 'rest}
   declare MutFuns{'fvars; 'pbunch; 'fbodies; 'cont}
   declare process_functions{'fvars; 'pbunch; 'fbodies}
   declare project_functions{'R; 'fvars; 'rest}
   declare bind_vars{'vars; 'e}
   declare norec_bind_vars{'vars; 'e}

   // Define our own list terms
   declare mcons{'element; 'list}
   declare mnil
}

// Place global code here.
// This section can be omitted.
{}

// Designate terminals.
// Options: -longest : match longest substring.
//          -first   : match first substring that matches.

Tokens -longest {
   ID = "[_a-zA-Z][_a-zA-Z0-9]*"    { __token__[p:s]{'pos} -> 'p }
   NUM = "[0-9]+"                   { __token__[p:s]{'pos} -> number[p:n] }

   AND = "and"                      {}
   ELSE = "else"                    {}
   END = "end"                      {}
   FUN = "fun"                      {}
   IF = "if"                        {}
   IN = "in"                        {}
   LET = "let"                      {}
   THEN = "then"                    {}
   REC = "rec"                      {}

   ARROW = "->"                     {}
   ASSIGN = "<-"                    {}
   COMMA = ","                      {}
   DIV = "/"                        {}
   DOT = "\\."                      {}
   EQ = "="                         {}
   GE = ">="                        {}
   GT = ">"                         {}
   LBRACK = "\\["                   {}
   LE = "<="                        {}
   LPAREN = "("                     {}
   LT = "<"                         {}
   MINUS = "-"                      {}
   NEQ = "<>"                       {}
   REM = "%"                        {}
   PLUS = "+"                       {}
   RBRACK = "\\]"                   {}
   RPAREN = ")"                     {}
   SEMI = ";"                       {}
   TIMES = "*"                      {}

   * COMMENT = "//[^\\n]*"          {}
   * EOL = "\\n"                    {}
   * SPACE = " "                    {}
}

// Specify associativity rules.
// Tokens appearing first have lower, 
// and tokens appearing on the same
// line have the same precendence.
// This section is optional.

%left prec_let
%left SEMI LET
%left ID prec_atom
%left ELSE
%left LT LE GT GE EQ NEQ
%left PLUS MINUS
%left TIMES DIV REM
%left LBRACK
%left LPAREN
%right prec_apply

// Specify grammar.
// Must supply a start symbol.

Grammar -start exp {
   exp ::=
    // Numbers
      NUM<number[i:n]>              => IntExpr[i:n]

    // Variables
    | ID<var[v:v]>                  => VarExpr{'v}

    // Anonymous functions
    | FUN ID<var[v:v]> ARROW exp<'e> %prec prec_let
                                    => LambdaExpr{v. 'e}
    // Binary operations
    | exp<'e1> PLUS exp<'e2>        => BinopExpr{AddOp{}; 'e1; 'e2}
    | exp<'e1> MINUS exp<'e2>       => BinopExpr{SubOp{}; 'e1; 'e2}
    | exp<'e1> TIMES exp<'e2>       => BinopExpr{MulOp{}; 'e1; 'e2}
    | exp<'e1> DIV exp<'e2>         => BinopExpr{DivOp{}; 'e1; 'e2}

    | exp<'e1> LE exp<'e2>          => RelopExpr{LeOp{}; 'e1; 'e2}
    | exp<'e1> LT exp<'e2>          => RelopExpr{LtOp{}; 'e1; 'e2}
    | exp<'e1> GE exp<'e2>          => RelopExpr{GeOp{}; 'e1; 'e2}
    | exp<'e1> GT exp<'e2>          => RelopExpr{GtOp{}; 'e1; 'e2}
    | exp<'e1> EQ exp<'e2>          => RelopExpr{EqOp{}; 'e1; 'e2}
    | exp<'e1> NEQ exp<'e2>         => RelopExpr{NeqOp{}; 'e1; 'e2}

    // Conditionals
    | IF exp<'e1> THEN exp<'e2> ELSE exp<'e3>
                                    => IfExpr{'e1; 'e2; 'e3}

    // Subscripting
    | exp<'e1> LBRACK exp<'e2> RBRACK
                                    => SubscriptExpr{'e1; 'e2}

    // Assignments
    | exp<'e1> LBRACK exp<'e2> RBRACK ASSIGN exp<'e3> %prec prec_let
                                    => AssignExpr{'e1; 'e2; 'e3}

    // Sequencing
    | exp<'e1> SEMI exp<'e2> %prec prec_let
                                    => SeqExpr{'e1; 'e2}

    // Function application
    | exp<'f> LPAREN args<'args> RPAREN %prec prec_apply
                                    => ApplyExpr{'f; 'args}

    // Let-definitions
    | LET ID<var[v:v]> EQ exp<'e1> IN exp<'e2> %prec prec_let
                                    => LetVarExpr{'e1; v. 'e2}

    // Recursive functions
    | LET REC funs<Functions{'funs; 'pbunch; 'bodies}> IN exp<'e> %prec prec_let
                                    => MutFuns{'funs; 'pbunch; 'bodies; 'e}
    // Non-recursive functions
    | LET fun<'fun> IN exp<'e2> %prec prec_let
                                    => NewFun{'fun; 'e2}


   funs ::= fun<SimpleFun{var[f:v]; 'params; 'body}>
                                    => Functions{mcons{'f; mnil{}}; mcons{'params; mnil{}}; mcons{'body; mnil{}}}
    | fun<SimpleFun{var[f:v]; 'params; 'body}> AND funs<Functions{'fvars; 'pbunch; 'fbodies}>
                                    => Functions{mcons{'f; 'fvars}; mcons{'params; 'pbunch}; mcons{'body; 'fbodies}}

   fun ::= ID<var[f:v]> LPAREN params<'params> RPAREN EQ exp<'e>
                                    => SimpleFun{'f; 'params; 'e}

   args ::= exp<'e>                 => ArgCons{'e; ArgNil{}}
    | exp<'e> COMMA args<'args>     => ArgCons{'e; 'args}

   params ::= ID<var[v:v]>          => mcons{'v; mnil{}}
    | ID<var[v:v]> COMMA params<'ids>
                                    => mcons{'v; 'ids}
}

// We want:
//
// LetRec{R. Fields{
//                FunDef{Label["fib":t]; LambdaExpr{i.
//                      LetFun{'R; Label["fib":t]; fib.
//                            ...}};
//                      FunDef{...;
//                            EndDef}}};
//          R. LetFun{'R; Label["fib":t]; fib.
//                ...}}

Rewrites {

   // Put all mutually recursive functions into a record.
   MutFuns{'fvars; 'pbunch; 'fbodies; 'rest} ->
      LetRec{R. Fields{process_functions{'R; 'fvars; 'fvars; 'pbunch; 'fbodies}};
         R. project_functions{'R; 'fvars; 'rest}}

   // process_functions{...} creates the fields of the record.
   process_functions{var[R:v]; 'funs; mcons{var[f:v]; 'fvars}; mcons{'params; 'pbunch}; mcons{'body; 'fbodies}} ->
      FunDef{Label[f:t];
         bind_vars{'R; 'funs; 'params; 'body};
         process_functions{'R; 'funs; 'fvars; 'pbunch; 'fbodies}}

   process_functions{?; ?; mnil{}; mnil{}; mnil{}} ->
      EndDef{}

   // Perform binding of function parameters (currying).
   // We project functions into variables in the innermost lambda.
   bind_vars{var[R:v]; 'fvars; mnil{}; 'body} ->
      project_functions{'R; 'fvars; 'body}

   bind_vars{var[R:v]; 'fvars; mcons{var[v:v]; 'vars}; 'body} ->
      LambdaExpr{v. bind_vars{'R; 'fvars; 'vars; 'body}}

   // Perform binding of function parameters (currying).
   // No function projection.
   norec_bind_vars{var[R:v]; 'fvars; mnil{}; 'body} ->
      'body

   norec_bind_vars{var[R:v]; 'fvars; mcons{var[v:v]; 'vars}; 'body} ->
      LambdaExpr{v. norec_bind_vars{'R; 'fvars; 'vars; 'body}}

   // project_functions{...} projects a list of functions into variables.
   project_functions{var[R:v]; mcons{var[f:v]; 'fvars}; 'rest} ->
      LetFun{'R; Label[f:t]; f. project_functions{'R; 'fvars; 'rest}}

   project_functions{?; mnil{}; 'rest} ->
      'rest

   // Process non-recursive functions.
   NewFun{SimpleFun{var[f:v]; 'params; 'body}; 'rest} ->
      LetRec{R. Fields{
         FunDef{Label[f:t]; norec_bind_vars{'R; mcons{var[f:v]; mnil{}}; 'params; 'body}; EndDef{}}};
         R. project_functions{'R; mcons{var[f:v]; mnil{}}; 'rest}}
}

