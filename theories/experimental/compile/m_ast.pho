(*
 * The M Abstract Syntax.
 *
 * ----------------------------------------------------------------
 * Copyright (C) 2003 Adam Granicz, Caltech
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; either version 2
 * of the License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
 *
 * Author: Adam Granicz
 * Email: granicz@cs.caltech.edu
 *)

Module M_ast

// Define the term-set to be used.

Terms -extend "M_ast" {
   // Arithmetic operators
   declare AstAddOp
   declare AstSubOp
   declare AstMulOp
   declare AstDivOp

   // Relational operators
   declare AstLeOp
   declare AstLtOp
   declare AstGeOp
   declare AstGtOp
   declare AstEqOp
   declare AstNeqOp

   // Simple expressions.
   declare TrueExpr
   declare FalseExpr
   declare IntExpr[n]
   declare BinopExpr{'op; 'e1; 'e2}
   declare RelopExpr{'op; 'e1; 'e2}
   declare VarExpr{'v}
   declare LambdaExpr{'e}
   declare FunLambdaExpr{'e}

   // If
   declare IfExpr{'e1; 'e2; 'e3}

   // Subscripting
   declare SubscriptExpr{'e1; 'e2}

   // Assignment
   declare AssignExpr{'e1; 'e2; 'e3; 'e4}

   // Function arguments
   declare AstArgNil
   declare AstArgCons{'a; 'rest}

   // Function calls and return
   declare ApplyExpr{'f; 'args}

   // Let-definition
   declare LetVarExpr{'e1 ;'e2}

   // Tuples
   declare AstAllocTupleNil
   declare AstAllocTupleCons{'a; 'rest}
   declare TupleExpr{'tuple}

   // Mutually recursive functions
   declare AstLetRec{'e1; 'e2}
   declare AstFields{'fields}
   declare AstLabel[t]
   declare AstFunDef{'label; 'exp; 'rest}
   declare AstEndDef

   // Function projection
   declare AstLetFun{'R; 'label; 'rest}

   // The main AST term
   declare AST{'e}
}

// These terms must be eliminated by the end of the
// informal post-parsing rewrites.

Terms -extend "$" {
   declare var_term[s]
   declare number[n]
   declare SimpleFun{'f; 'params; 'body}
   declare Functions{'fvars; 'pbunch; 'fbodies}
   declare NewFun{'fun; 'rest}
   declare MutFuns{'fvars; 'pbunch; 'fbodies; 'cont}
   declare process_functions{'fvars; 'pbunch; 'fbodies}
   declare project_functions{'R; 'fvars; 'rest}
   declare first_bind_vars{'R; 'fvars; 'vars; 'e}
   declare bind_vars{'R; 'fvars; 'vars; 'e}
   declare first_norec_bind_vars{'R; 'vars; 'e}
   declare norec_bind_vars{'R; 'vars; 'e}

   // Define our own list terms
   declare mcons{'element; 'list}
   declare mnil
}

// Place global code here.
// This section can be omitted.
{}

// Designate terminals.
// Options: -longest : match longest substring.
//          -first   : match first substring that matches.

Tokens -longest {
   ID = "[_a-zA-Z][_a-zA-Z0-9]*"    { __token__[p:s]{'pos} -> var_term[p:s] }
   NUM = "[0-9]+"                   { __token__[p:s]{'pos} -> number[p:n] }
   ID2 = "&&"                       { __token__[p:s]{'pos} -> 'p }

   AND = "and"                      {}
   ELSE = "else"                    {}
   END = "end"                      {}
   FALSE = "false"                  {}
   FUN = "fun"                      {}
   IF = "if"                        {}
   IN = "in"                        {}
   LET = "let"                      {}
   THEN = "then"                    {}
   TRUE = "true"                    {}
   REC = "rec"                      {}

   ARROW = "->"                     {}
   ASSIGN = "<-"                    {}
   COMMA = ","                      {}
   DIV = "/"                        {}
   DOT = "\\."                      {}
   EQ = "="                         {}
   GE = ">="                        {}
   GT = ">"                         {}
   LBRACK = "\\["                   {}
   LE = "<="                        {}
   LPAREN = "("                     {}
   LT = "<"                         {}
   MINUS = "-"                      {}
   NEQ = "<>"                       {}
   REM = "%"                        {}
   PLUS = "+"                       {}
   RBRACK = "\\]"                   {}
   RPAREN = ")"                     {}
   SEMI = ";"                       {}
   TIMES = "*"                      {}

   * COMMENT = "//[^\\n]*"          {}
   * EOL = "\\n"                    {}
   * SPACE = " "                    {}
}

// Specify associativity rules.
// Tokens appearing first have lower, 
// and tokens appearing on the same
// line have the same precendence.
// This section is optional.

%right prec_seq
%right prec_let
%left SEMI LET
%left ID prec_atom
%left ELSE
%left LT LE GT GE EQ NEQ
%left PLUS MINUS
%left TIMES DIV REM
%left LBRACK
%left LPAREN
%right prec_apply

// Specify grammar.
// Must supply a start symbol.

Grammar -start main {
   main ::=
      exp<'e>                       => AST{'e}

   exp ::=
    // Numbers
      NUM<number[i:n]>              => IntExpr[i:n]

    // Booleans
    | TRUE                          => TrueExpr{}
    | FALSE                         => FalseExpr{}

    // Variables
    | ID<var_term[v:s]>             => VarExpr{'v}

    // Anonymous functions
    | FUN ID<var_term[v:s]> ARROW exp<'e> %prec prec_let
                                    => LambdaExpr{v. 'e}
    // Tuples
    | LPAREN tuple<'tuple> RPAREN   => TupleExpr{'tuple}

    // Binary operations
    | exp<'e1> PLUS exp<'e2>        => BinopExpr{AstAddOp{}; 'e1; 'e2}
    | exp<'e1> MINUS exp<'e2>       => BinopExpr{AstSubOp{}; 'e1; 'e2}
    | exp<'e1> TIMES exp<'e2>       => BinopExpr{AstMulOp{}; 'e1; 'e2}
    | exp<'e1> DIV exp<'e2>         => BinopExpr{AstDivOp{}; 'e1; 'e2}

    // Relational operations
    | exp<'e1> LE exp<'e2>          => RelopExpr{AstLeOp{}; 'e1; 'e2}
    | exp<'e1> LT exp<'e2>          => RelopExpr{AstLtOp{}; 'e1; 'e2}
    | exp<'e1> GE exp<'e2>          => RelopExpr{AstGeOp{}; 'e1; 'e2}
    | exp<'e1> GT exp<'e2>          => RelopExpr{AstGtOp{}; 'e1; 'e2}
    | exp<'e1> EQ exp<'e2>          => RelopExpr{AstEqOp{}; 'e1; 'e2}
    | exp<'e1> NEQ exp<'e2>         => RelopExpr{AstNeqOp{}; 'e1; 'e2}

    // Conditionals
    | IF exp<'e1> THEN exp<'e2> ELSE exp<'e3>
                                    => IfExpr{'e1; 'e2; 'e3}

    // Subscripting
    | exp<'e1> LBRACK exp<'e2> RBRACK
                                    => SubscriptExpr{'e1; 'e2}

    // Assignments
    | exp<'e1> LBRACK exp<'e2> RBRACK ASSIGN exp<'e3> SEMI exp<'e4> %prec prec_let
                                    => AssignExpr{'e1; 'e2; 'e3; 'e4}

    // Function application
    | exp<'f> LPAREN args<'args> RPAREN %prec prec_apply
                                    => ApplyExpr{'f; 'args}

    // Let-definitions
    | LET ID<var_term[v:s] /*var[v:v]*/> EQ exp<'e1> IN exp<'e2> %prec prec_let
                                    => LetVarExpr{'e1; v. 'e2}

    // Recursive functions
    | LET REC funs<Functions{'funs; 'pbunch; 'bodies}> IN exp<'e> %prec prec_let
                                    => MutFuns{'funs; 'pbunch; 'bodies; 'e}
    // Non-recursive functions
    | LET fun<'fun> IN exp<'e2> %prec prec_let
                                    => NewFun{'fun; 'e2}

   tuple ::= exp<'e>                => AstAllocTupleCons{'e; AstAllocTupleNil{}}
    | exp<'e> COMMA tuple<'tuple>   => AstAllocTupleCons{'e; 'tuple}

   funs ::= fun<SimpleFun{var_term[f:s]; 'params; 'body}>
                                    => Functions{mcons{var_term[f:s]; mnil{}}; mcons{'params; mnil{}}; mcons{'body; mnil{}}}
    | fun<SimpleFun{var_term[f:s]; 'params; 'body}> AND funs<Functions{'fvars; 'pbunch; 'fbodies}>
                                    => Functions{mcons{var_term[f:s]; 'fvars}; mcons{'params; 'pbunch}; mcons{'body; 'fbodies}}

   fun ::= ID<var_term[f:s]> LPAREN params<'params> RPAREN EQ exp<'e>
                                    => SimpleFun{var_term[f:s]; 'params; 'e}

   args ::= exp<'e>                 => AstArgCons{'e; AstArgNil{}}
    | exp<'e> COMMA args<'args>     => AstArgCons{'e; 'args}

   params ::= ID<var_term[v:s]>     => mcons{var_term[v:s]; mnil{}}
    | ID<var_term[v:s]> COMMA params<'ids>
                                    => mcons{var_term[v:s]; 'ids}
}

// We want:
//
// AstLetRec{R. AstFields{
//                AstFunDef{AstLabel["fib":t]; LambdaExpr{i.
//                      AstLetFun{'R; AstLabel["fib":t]; fib.
//                            ...}};
//                      AstFunDef{...;
//                            AstEndDef}}};
//          R. AstLetFun{'R; AstLabel["fib":t]; fib.
//                ...}}

Rewrites {

   // Put all mutually recursive functions into a record.
   MutFuns{'fvars; 'pbunch; 'fbodies; 'rest} ->
      AstLetRec{R. AstFields{process_functions{'R; 'fvars; 'fvars; 'pbunch; 'fbodies}};
         R. project_functions{'R; 'fvars; 'rest}}

   // process_functions{...} creates the fields of the record.
   process_functions{'R; 'funs; mcons{var_term[f:s]; 'fvars}; mcons{'params; 'pbunch}; mcons{'body; 'fbodies}} ->
      AstFunDef{AstLabel[f:t];
         first_bind_vars{'R; 'funs; 'params; 'body};
         process_functions{'R; 'funs; 'fvars; 'pbunch; 'fbodies}}

   process_functions{?; ?; mnil{}; mnil{}; mnil{}} ->
      AstEndDef{}

   // Perform binding of function parameters (currying).
   // We project functions into variables in the innermost lambda.
   // Note: we use FunLambdaExpr for the outermost lambda, and
   //       LambdaExpr for the others.

   first_bind_vars{'R; 'fvars; mnil{}; 'body} ->
      project_functions{'R; 'fvars; 'body}

   first_bind_vars{'R; 'fvars; mcons{var_term[v:s]; 'vars}; 'body} ->
      FunLambdaExpr{v. bind_vars{'R; 'fvars; 'vars; 'body}}

   bind_vars{'R; 'fvars; mnil{}; 'body} ->
      project_functions{'R; 'fvars; 'body}

   bind_vars{'R; 'fvars; mcons{var_term[v:s]; 'vars}; 'body} ->
      LambdaExpr{v. bind_vars{'R; 'fvars; 'vars; 'body}}

   // Perform binding of function parameters (currying).
   // No function projection.
   first_norec_bind_vars{'R; mnil{}; 'body} ->
      'body

   first_norec_bind_vars{'R; mcons{var_term[v:s]; 'vars}; 'body} ->
      FunLambdaExpr{v. norec_bind_vars{'R; 'vars; 'body}}

   norec_bind_vars{'R; mnil{}; 'body} ->
      'body

   norec_bind_vars{'R; mcons{var_term[v:s]; 'vars}; 'body} ->
      LambdaExpr{v. norec_bind_vars{'R; 'vars; 'body}}

   // project_functions{...} projects a list of functions into variables.
   project_functions{'R; mcons{var_term[f:s]; 'fvars}; 'rest} ->
      AstLetFun{'R; AstLabel[f:t]; f. project_functions{'R; 'fvars; 'rest}}

   project_functions{?; mnil{}; 'rest} ->
      'rest

   // Process non-recursive functions.
   NewFun{SimpleFun{var_term[f:s]; 'params; 'body}; 'rest} ->
      AstLetRec{R. AstFields{
         AstFunDef{AstLabel[f:t]; first_norec_bind_vars{'R; 'params; 'body}; AstEndDef{}}};
         R. project_functions{'R; mcons{var_term[f:s]; mnil{}}; 'rest}}
}

