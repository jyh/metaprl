(*
 * The M Abstract Syntax.
 *
 * We perform currying and proper binding of mutually recursive
 * functions.
 *
 * ----------------------------------------------------------------
 * Copyright (C) 2003 Adam Granicz, Caltech
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; either version 2
 * of the License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
 *
 * Author: Adam Granicz
 * Email: granicz@cs.caltech.edu
 *)

Module M_ast

// Define the term-set to be used.

Terms -extend "M_ir" {
   // Arithmetic operators
   declare AddOp
   declare SubOp
   declare MulOp
   declare DivOp

   // Relational operators
   declare LeOp
   declare LtOp
   declare GeOp
   declare GtOp
   declare EqOp
   declare NeqOp

   // Atoms
   declare AtomFalse
   declare AtomTrue
   declare AtomInt[n]
   declare AtomBinop{'op; 'a1; 'a2}
   declare AtomRelop{'op; 'a1; 'a2}
   declare AtomFun{'e}
   declare AtomVar{'v}

   // LetAtom
   declare LetAtom{'a; 'e}

   // If
   declare If{'a; 'e1; 'e2}

   // Function arguments
   declare ArgNil
   declare ArgCons{'a; 'rest}

   // Function calls and return
   declare TailCall{'f; 'args}
   declare LetApply{'f; 'a; 'e}
   declare Return{'a}

   // Tuples
   declare Length[n]
   declare AllocTupleNil
   declare AllocTupleCons{'a; 'rest}
   declare LetTuple{'length; 'tuple; 'e}

   // Subscripting
   declare LetSubscript{'a1; 'a2; 'e}
   declare SetSubscript{'a1; 'a2; 'a3; 'e}

   // Mutually recursive functions
   declare LetRec{'e1; 'e2}
   declare Fields{'fields}
   declare Label[t]
   declare FunDef{'label; 'exp; 'rest}
   declare EndDef

   // Function projection
   declare LetFun{'R; 'label; 'rest}
}

// These terms must be eliminated by the end of the
// informal post-parsing rewrites.

Terms -extend "$" {
   declare SimpleFun{'f; 'params; 'body}
   declare Functions{'fvars; 'pbunch; 'fbodies}
   declare NewFun{'fun; 'rest}
   declare MutFuns{'fvars; 'pbunch; 'fbodies; 'cont}
   declare process_functions{'fvars; 'pbunch; 'fbodies}
   declare project_functions{'R; 'fvars; 'rest}
   declare bind_vars{'vars; 'e}
   declare norec_bind_vars{'vars; 'e}

   // Define our own list terms
   declare mcons{'element; 'list}
   declare mnil
}

// Place global code here.
// This section can be omitted.
{}

// Designate terminals.
// Options: -longest : match longest substring.
//          -first   : match first substring that matches.

Tokens -longest {
   ID = "[_a-zA-Z][_a-zA-Z0-9]*"    { __token__[p:s]{'pos} -> 'p }
   NUM = "[0-9]+"                   { __token__[p:s]{'pos} -> AtomInt[p:n] }

   AND = "and"                      {}
   ELSE = "else"                    {}
   END = "end"                      {}
   FUN = "fun"                      {}
   IF = "if"                        {}
   IN = "in"                        {}
   LET = "let"                      {}
   THEN = "then"                    {}
   REC = "rec"                      {}

   ARROW = "->"                     {}
   ASSIGN = "<-"                    {}
   COMMA = ","                      {}
   DIV = "/"                        {}
   DOT = "\\."                      {}
   EQ = "="                         {}
   GE = ">="                        {}
   GT = ">"                         {}
   LBRACK = "\\["                   {}
   LE = "<="                        {}
   LPAREN = "("                     {}
   LT = "<"                         {}
   MINUS = "-"                      {}
   NEQ = "<>"                       {}
   REM = "%"                        {}
   PLUS = "+"                       {}
   RBRACK = "\\]"                   {}
   RPAREN = ")"                     {}
   SEMI = ";"                       {}
   TIMES = "*"                      {}

   * COMMENT = "//[^\\n]*"          {}
   * EOL = "\\n"                    {}
   * SPACE = " "                    {}
}

// Specify associativity rules.
// Tokens appearing first have lower, 
// and tokens appearing on the same
// line have the same precendence.
// This section is optional.

%left ID prec_atom
%left ELSE
%left LT LE GT GE EQ NEQ
%left PLUS MINUS
%left TIMES DIV REM
%left LBRACK
%left LPAREN
%right prec_apply

// Specify grammar.
// Must supply a start symbol.

Grammar -start exp {
   exp ::= LET ID<var[v:v]> EQ a<'a> IN exp<'e>
                                    => LetAtom{'a; v. 'e}
    | LET REC funs<Functions{'funs; 'pbunch; 'bodies}> IN exp<'e>
                                    => MutFuns{'funs; 'pbunch; 'bodies; 'e}
    | LET fun<'fun> IN exp<'e2>     => NewFun{'fun; 'e2}
    | LET ID<var[v:v]> EQ a<'a1> LBRACK a<'a2> RBRACK IN exp<'e>
                                    => LetSubscript{'a1; 'a2; v. 'e}
    | LET ID<var[v:v]> EQ a<'f> LPAREN args<'args> RPAREN IN exp<'e>
                                    => LetApply{'f; 'args; v. 'e}
//    | LET ID<var[v:v]> EQ LPAREN a<'a1> COMMA a<'a2> RPAREN IN exp<'e>
//                                    => LetPair{'a1; 'a2; v. 'e}
    | ID<var[f:v]> LPAREN args<'args> RPAREN %prec prec_apply
                                    => TailCall{AtomVar{'f}; 'args}
    | IF a<'a> THEN exp<'e1> ELSE exp<'e2>
                                    => If{'a; 'e1; 'e2}
    | a<'a1> LBRACK a<'a2> RBRACK ASSIGN a<'a3> SEMI exp<'e>
                                    => SetSubscript{'a1; 'a2; 'a3; 'e}
    | a<'a> %prec prec_atom         => Return{'a}

   funs ::= fun<SimpleFun{var[f:v]; 'params; 'body}>
                                    => Functions{mcons{'f; mnil{}}; mcons{'params; mnil{}}; mcons{'body; mnil{}}}
      | fun<SimpleFun{var[f:v]; 'params; 'body}> AND funs<Functions{'fvars; 'pbunch; 'fbodies}>
                                    => Functions{mcons{'f; 'fvars}; mcons{'params; 'pbunch}; mcons{'body; 'fbodies}}

   fun ::= ID<var[f:v]> LPAREN id_list<'params> RPAREN EQ exp<'e>
                                    => SimpleFun{'f; 'params; 'e}

   a ::= NUM<'i>                    => 'i
      | ID<var[v:v]>                => AtomVar{'v}
      | FUN ID<var[v:v]> ARROW exp<'e>
                                    => AtomFun{v. 'e}
      | a<'a1> PLUS a<'a2>          => AtomBinop{AddOp{}; 'a1; 'a2}
      | a<'a1> MINUS a<'a2>         => AtomBinop{SubOp{}; 'a1; 'a2}
      | a<'a1> TIMES a<'a2>         => AtomBinop{MulOp{}; 'a1; 'a2}
      | a<'a1> DIV a<'a2>           => AtomBinop{DivOp{}; 'a1; 'a2}

      | a<'a1> LE a<'a2>            => AtomRelop{LeOp{}; 'a1; 'a2}
      | a<'a1> LT a<'a2>            => AtomRelop{LtOp{}; 'a1; 'a2}
      | a<'a1> GE a<'a2>            => AtomRelop{GeOp{}; 'a1; 'a2}
      | a<'a1> GT a<'a2>            => AtomRelop{GtOp{}; 'a1; 'a2}
      | a<'a1> EQ a<'a2>            => AtomRelop{EqOp{}; 'a1; 'a2}
      | a<'a1> NEQ a<'a2>           => AtomRelop{NeqOp{}; 'a1; 'a2}

   args ::= a<'a>                   => ArgCons{'a; ArgNil{}}
      | a<'a> COMMA args<'args>     => ArgCons{'a; 'args}

   id_list ::= ID<var[v:v]>         => mcons{'v; mnil{}}
      | ID<var[v:v]> COMMA id_list<'ids>
                                    => mcons{'v; 'ids}
}

// We want:
//
// LetRec{R. Fields{
//                FunDef{Label["fib":t]; AtomFun{i.
//                      LetFun{'R; Label["fib":t]; fib.
//                            ...}};
//                      FunDef{...;
//                            EndDef}}};
//          R. LetFun{'R; Label["fib":t]; fib.
//                ...}}

Rewrites {

   // Put all mutually recursive functions into a record.
   MutFuns{'fvars; 'pbunch; 'fbodies; 'rest} ->
      LetRec{R. Fields{process_functions{'R; 'fvars; 'fvars; 'pbunch; 'fbodies}};
         R. project_functions{'R; 'fvars; 'rest}}

   // process_functions{...} creates the fields of the record.
   process_functions{var[R:v]; 'funs; mcons{var[f:v]; 'fvars}; mcons{'params; 'pbunch}; mcons{'body; 'fbodies}} ->
      FunDef{Label[f:t];
         bind_vars{'R; 'funs; 'params; 'body};
         process_functions{'R; 'funs; 'fvars; 'pbunch; 'fbodies}}

   process_functions{?; ?; mnil{}; mnil{}; mnil{}} ->
      EndDef{}

   // Perform binding of function parameters (currying).
   // We project functions into variables in the innermost lambda.
   bind_vars{var[R:v]; 'fvars; mnil{}; 'body} ->
      project_functions{'R; 'fvars; 'body}

   bind_vars{var[R:v]; 'fvars; mcons{var[v:v]; 'vars}; 'body} ->
      AtomFun{v. bind_vars{'R; 'fvars; 'vars; 'body}}

   // Perform binding of function parameters (currying).
   // No function projection.
   norec_bind_vars{var[R:v]; 'fvars; mnil{}; 'body} ->
      'body

   norec_bind_vars{var[R:v]; 'fvars; mcons{var[v:v]; 'vars}; 'body} ->
      AtomFun{v. norec_bind_vars{'R; 'fvars; 'vars; 'body}}

   // project_functions{...} projects a list of functions into variables.
   project_functions{var[R:v]; mcons{var[f:v]; 'fvars}; 'rest} ->
      LetFun{'R; Label[f:t]; f. project_functions{'R; 'fvars; 'rest}}

   project_functions{?; mnil{}; 'rest} ->
      'rest

   // Process non-recursive functions.
   NewFun{SimpleFun{var[f:v]; 'params; 'body}; 'rest} ->
      LetRec{R. Fields{
         FunDef{Label[f:t]; norec_bind_vars{'R; mcons{var[f:v]; mnil{}}; 'params; 'body}; EndDef{}}};
         R. project_functions{'R; mcons{var[f:v]; mnil{}}; 'rest}}
}
