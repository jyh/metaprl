(*
 * The register allocator performs the following steps:
 *    1. Code generation
 *    2. Register assignment
 *    3. Move coalescing
 *
 * ----------------------------------------------------------------
 *
 * Copyright (C) 1999 Jason Hickey, Caltech
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; either version 2
 * of the License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
 *
 * Author: Jason Hickey
 * jyh@cs.caltech.edu
 *)
extends M_ra_live

open Lm_flags
open Lm_symbol
open Lm_symbol_matrix
open Lm_printf

open M_ra_type
open M_ra_live
open M_ra_state

module MakeRegAlloc (Frame : FrameSig)
: RegAllocSig
  with type block = Frame.inst Frame.block =
struct
   type block = Frame.inst Frame.block

   (*
    * Modules.
    *)
   module Liveness = MakeLive (Frame)

   (*
    * Set of pairs.
    *)
   module Var2Compare =
   struct
      type t = var * var

      let compare (v11, v12) (v21, v22) =
         let cmp = Lm_symbol.compare v11 v21 in
            if cmp = 0 then
               Lm_symbol.compare v12 v22
            else
               cmp
   end

   module MoveSet = Lm_set.LmMake (Var2Compare)

   (*
    * Classification for nodes.
    * A node can be:
    *    Precolored: a machine register
    *    SimpWL: on the simplify worklist
    *    SpillWL: on the spill worklist
    *    Spilled: spilled
    *    Coalesced: coalesced (set equal to another node)
    *    Colored: assigned to a machine register
    *    Stack: placed on the allocation stack
    *
    * We want to support two functions efficiently:
    *    reclassify node class: reclassify a node
    *    nodes_in_class class: all the nodes with a given class
    *
    * Reclassify takes constant time.
    *)
   type node_class =
      NodePrecolored
    | NodeInitial
    | NodeSimpWL
    | NodeFreezeWL
    | NodeSpillWL
    | NodeSpilled
    | NodeCoalesced
    | NodeColored
    | NodeStack

   (*
    * Moves are also classified.
    *    Coalesced: move has been coalesced
    *    Constrained: the nodes in the move interfere
    *    Frozen: move is not being considered for coalescing
    *    WL: on the move worklist for consideration
    *    Active: may be considered for coalescing eventually
    *)
   type move_class =
      MoveCoalesced
    | MoveConstrained
    | MoveFrozen
    | MoveWL
    | MoveActive

   (*
    * For each node we keep
    *    node_name: the variable name of the node
    *    node_length: length of the shortest live range
    *    node_reg_class: the register class (float, int, etc)
    *    node_base_cost: the def/use cost for non-move instructions
    *    node_move_cost: the estimated cost of freezing all moves; if negative, it should be recomputed
    *    node_total_cost: the estimated cost of spilling; if negative, it should be recomputed
    *    node_class: the current classification of the node
    *    node_degree: the number of neighbors
    *    node_alias: a new name for the node
    *    node_color: color that is assigned to a node
    *    node_moves: all the moves the node is in
    *    node_neighbors: the list of neighbors that are not moves
    *    node_move_neighbors: the list of neighbors generated by a MOV instruction
    *)
   type node =
      { node_name : var;
        node_reg_class : reg_class;
        node_length : int;
        mutable node_total_length : int;
        mutable node_base_cost : int;
        mutable node_move_cost : int;
        mutable node_total_cost : int;
        mutable node_class : node_class;
        mutable node_degree : int;
        mutable node_alias : node option;
        mutable node_color : var option;
        mutable node_moves : move list;

        (* Neighbor lists *)
        mutable node_neighbors : node SymbolTable.t;

        (* Linked list *)
        mutable node_pred : node option ref;
        node_succ : node option ref
      }

   (*
    * For the move
    *    move_dst: dst of the move
    *    move_src: src of the move\
    *    move_depth: number of times the move occurs at various depths
    *    move_class: current classification of the move
    *)
   and move =
      { move_dst : node;
        move_src : node;
        move_depth : int array;

        (* Classification of the move *)
        mutable move_class : move_class;

        (* Linked list *)
        mutable move_pred : move option ref;
        move_succ : move option ref
      }

   (*
    * All this stuff is defined in Appel,
    * "Modern Compiler Implementation in ML",
    * 1998, Cambridge University Press,
    * pages 242-243.
    *)
   type ra =
      { (* Node worklists *)
        mutable ra_list : node list;
        ra_precolored : node option ref;
        ra_initial : node option ref;
        ra_simp_wl : node option ref;
        ra_freeze_wl : node option ref;
        ra_spill_wl : node option ref;
        ra_spilled : node option ref;
        ra_coalesced : node option ref;
        ra_colored : node option ref;
        ra_stack : node option ref;

        (* Move worklists *)
        mutable mv_list : move list;
        mv_coalesced : move option ref;
        mv_constrained : move option ref;
        mv_frozen : move option ref;
        mv_wl : move option ref;
        mv_active : move option ref;

        (* Explicit representation of the graph *)
        ra_edges : bool SymSymbolMatrix.t
      }

   (*
    * Maximum weight we place on a node to avoid overflow.
    *)
   let max_weight = 100000

   (************************************************************************
    * REGISTERS AND CLASSES
    ************************************************************************)

   (*
    * Subtract the special registers: they can never be
    * allocated.
    *)
   let registers =
      Array.mapi (fun i vars ->
            SymbolSet.subtract_list (SymbolSet.of_list vars) Frame.registers_special.(i)) Frame.registers

   (*
    * Add all the special registers to a list so we can
    * remove them during liveness.
    *)
   let all_special =
      let rec collect regs i =
         if i = Frame.reg_class_count then
            regs
         else
            collect (regs @ Frame.registers_special.(i)) (succ i)
      in
         collect [] 0

   (*
    * Precolored nodes.
    *
    * Number of colors assigned to registers.
    *)
   let max_colors = Array.map SymbolSet.cardinal registers

   (*
    * All the registers that are precolored.
    *)
   let is_precolored =
      let rec collect regs i =
         if i = Frame.reg_class_count then
            regs
         else
            collect (SymbolSet.add_list regs Frame.registers.(i)) (succ i)
      in
      let precolored = collect SymbolSet.empty 0 in
         SymbolSet.mem precolored

   (*
    * Look up a node class.
    *)
   let cenv_lookup cenv v =
      try SymbolTable.find cenv v with
         Not_found ->
            raise (Invalid_argument ("Regalloc: unclassified var: " ^ string_of_symbol v))

   (************************************************************************
    * NODE OPERATIONS
    ************************************************************************)

   (*
    * Get the list pointer for a node class.
    *)
   let node_worklist ra_nodes = function
      NodePrecolored -> ra_nodes.ra_precolored
    | NodeInitial -> ra_nodes.ra_initial
    | NodeSimpWL -> ra_nodes.ra_simp_wl
    | NodeFreezeWL -> ra_nodes.ra_freeze_wl
    | NodeSpillWL -> ra_nodes.ra_spill_wl
    | NodeSpilled -> ra_nodes.ra_spilled
    | NodeCoalesced -> ra_nodes.ra_coalesced
    | NodeColored -> ra_nodes.ra_colored
    | NodeStack -> ra_nodes.ra_stack

   let string_of_node_class = function
      NodePrecolored -> "Precolored"
    | NodeInitial -> "Initial"
    | NodeSimpWL -> "SimpWL"
    | NodeFreezeWL -> "FreezeWL"
    | NodeSpillWL -> "SpillWL"
    | NodeSpilled -> "Spilled"
    | NodeCoalesced -> "Coalesced"
    | NodeColored -> "Colored"
    | NodeStack -> "Stack"

   (*
    * Test for empty.
    *)
   let node_list_is_empty ra cl =
      let l = node_worklist ra cl in
         match !l with
            Some _ -> false
          | None -> true

   (*
    * Get the head of a list.
    *)
   let node_list_head ra cl =
      let l = node_worklist ra cl in
         match !l with
            Some node -> node
          | None -> raise (Invalid_argument "node_list_head")

   (*
    * Iterate through the node list.
    *)
   let node_iter ra cl f =
      let rec iter = function
         Some node ->
            let next = !(node.node_succ) in
               f node;
               iter next
       | None ->
            ()
      in
         iter (!(node_worklist ra cl))

   let node_fold ra cl f x =
      let rec fold x node =
         match node with
            Some node ->
               let next = !(node.node_succ) in
               let x = f x node in
                  fold x next
          | None ->
               x
      in
         fold x (!(node_worklist ra cl))

   let node_to_list ra cl =
      let rec collect = function
         Some node ->
            node :: collect (!(node.node_succ))
       | None ->
            []
      in
         collect (!(node_worklist ra cl))

   (*
    * Get successor node.
    *)
   let node_succ node =
      match !(node.node_succ) with
         Some node -> node
       | None -> raise (Invalid_argument "node_succ")

   (*
    * Has a succ?
    *)
   let node_has_no_succ node =
      match !(node.node_succ) with
         Some _ -> false
       | None -> true

   (*
    * Get the alias for a node.
    *)
   let rec node_alias node =
      match node.node_alias with
         Some node ->
            node_alias node
       | None ->
            node

   (*
    * Node has some moves.
    *)
   let node_is_move_related node =
      List.exists (fun move ->
            match move.move_class with
               MoveWL
             | MoveActive ->
                  true
             | MoveCoalesced
             | MoveFrozen
             | MoveConstrained ->
                  false) node.node_moves

   (*
    * Check that the node degree is reasonable.
    *)
   let node_is_checkable node =
      match node.node_class with
         NodeStack
       | NodeColored
       | NodeCoalesced
       | NodeSpilled
       | NodePrecolored ->
            false
       | NodeInitial
       | NodeSimpWL
       | NodeFreezeWL
       | NodeSpillWL ->
            true

   let node_check pos ra node1 =
      (* Check for duplicate nodes *)
      if !debug_regalloc >= 1 && node_is_checkable node1 then
         let name1 = node1.node_name in
         let s1 = string_of_symbol node1.node_name in
         let nodes =
            SymbolTable.fold (fun nodes _ node2 ->
                  let name2 = node2.node_name in
                  let nodes =
                     match node2.node_class with
                        NodeStack
                      | NodeCoalesced
                      | NodeSpilled ->
                           nodes
                      | NodePrecolored
                      | NodeInitial
                      | NodeSimpWL
                      | NodeFreezeWL
                      | NodeSpillWL
                      | NodeColored ->
                           node2 :: nodes
                  in
                     if not (SymSymbolMatrix.query ra.ra_edges name1 name2) then
                        raise (Invalid_argument (Lm_printf.sprintf
                           "%s[%s]: %s: illegal neighbor: %s" (**)
                           pos (string_of_node_class node1.node_class) s1 (string_of_symbol name2)));
                     nodes) [] node1.node_neighbors
         in
         let len1 = node1.node_degree in
         let len2 = List.length nodes in
         let max_colors = max_colors.(node1.node_reg_class) in
            (*
             * Invariant: nodes on SpillWL have significant degree.
             *)
            if node1.node_class = NodeSpillWL then
               begin
                  if len1 < max_colors then
                     raise (Invalid_argument (Lm_printf.sprintf
                        "%s[%s]: class is wrong: %s: degree = %d" (**)
                        pos (string_of_node_class node1.node_class) s1 len1))
               end;

            (*
             * Invariant: nodes on FreezeWL have insignificant degree.
             *)
            if node1.node_class = NodeFreezeWL then
               begin
                  let moveb = node_is_move_related node1 in
                     if len1 >= max_colors || not moveb then
                        raise (Invalid_argument (Lm_printf.sprintf
                           "%s[%s]: class is wrong: %s: degree = %d, move_related = %b" (**)
                           pos (string_of_node_class node1.node_class) s1 len1 moveb))
               end;

            (*
             * Invariant: nodes on SimpWL are not move related.
             *)
            if node1.node_class = NodeSimpWL then
               begin
                  let moveb = node_is_move_related node1 in
                     if len1 >= max_colors || moveb then
                        raise (Invalid_argument (Lm_printf.sprintf
                           "%s[%s]: class is wrong: %s: degree = %d, move_related = %b" (**)
                           pos (string_of_node_class node1.node_class) s1 len1 moveb))
               end;

            (*
             * Invariant: degree invariant.
             *)
            if len1 <> len2 then
               let neighbors = node1.node_neighbors in
               let len_precolored =
                  SymbolTable.fold (fun count _ node ->
                        match node.node_class with
                           NodePrecolored ->
                              succ count
                         | _ ->
                              count) 0 neighbors
               in
               let len_colored =
                  SymbolTable.fold (fun count _ node ->
                        match node.node_class with
                           NodeColored ->
                              succ count
                         | _ ->
                              count) 0 neighbors
               in
               let len_freeze =
                  SymbolTable.fold (fun count _ node ->
                        match node.node_class with
                           NodeFreezeWL ->
                              succ count
                         | _ ->
                              count) 0 neighbors
               in
               let len_spill =
                  SymbolTable.fold (fun count _ node ->
                        match node.node_class with
                           NodeSpillWL ->
                              succ count
                         | _ ->
                              count) 0 neighbors
               in
               let len_coalesced =
                  SymbolTable.fold (fun count _ node ->
                        match node.node_class with
                           NodeCoalesced ->
                              succ count
                         | _ ->
                              count) 0 neighbors
               in
               let len_simp =
                  SymbolTable.fold (fun count _ node ->
                        match node.node_class with
                           NodeSimpWL ->
                              succ count
                         | _ ->
                              count) 0 neighbors
               in
               let len_stack =
                  SymbolTable.fold (fun count _ node ->
                        match node.node_class with
                           NodeStack ->
                              succ count
                         | _ ->
                              count) 0 neighbors
               in
                  raise (Invalid_argument (Lm_printf.sprintf
                     "%s[%s]: degree is wrong: %s: degree = %d, neighbors = %d, precolored = %d, freeze = %d, spillwl = %d, colored = %d, coalesced = %d, simp = %d, stack = %d" (**)
                     pos (string_of_node_class node1.node_class) s1 len1 len2 len_precolored len_freeze len_spill len_colored len_coalesced len_simp len_stack))

   let ra_check deb ra =
      if !debug_regalloc >= 2 then
         List.iter (node_check deb ra) ra.ra_list

   (*
    * Use this value for the total cost to recompute
    * it on the next analysis.
    *)
   let recompute_cost = -1

   (*
    * Create a node in a class.
    *)
   let new_node ra v (length, def_cost, use_cost) cl reg_class =
      let l = node_worklist ra cl in
      let next = !l in
      let succ = ref next in

         eprintf "New node: %a, length = %d@." pp_print_symbol v length;

      (* Postpone computation of neighbors *)
      let node =
         { node_name = v;
           node_length = length;
           node_total_length = length;
           node_base_cost = def_cost + use_cost;
           node_move_cost = recompute_cost;
           node_total_cost = recompute_cost;
           node_reg_class = reg_class;
           node_class = cl;
           node_degree = 0;
           node_alias = None;
           node_color = None;
           node_neighbors = SymbolTable.empty;
           node_moves = [];
           node_pred = l;
           node_succ = succ
         }
      in
      let _ =
         (* Link it into the list *)
         l := Some node;
         match next with
            Some next -> next.node_pred <- succ
          | None -> ()
      in
         ra.ra_list <- node :: ra.ra_list;
         node_check "new_node" ra node;
         node

   (*
    * Reclassify the node.
    *)
   let node_reclassify ra node cl =
      (* Delete the node from its current list *)
      let pred = node.node_pred in
      let succ = !(node.node_succ) in
      let _ =
         pred := succ;
         match succ with
            Some next -> next.node_pred <- pred
          | None -> ()
      in

      (* Add to the new list *)
      let l = node_worklist ra cl in
      let next = !l in
         l := Some node;
         assert(node.node_class <> NodePrecolored);
         node.node_class <- cl;
         node.node_pred <- l;
         node.node_succ := next;
         (match next with
             Some next -> next.node_pred <- node.node_succ
           | None -> ())

   (*
    * Test for equality.
    *)
   let node_eq node1 node2 =
      Lm_symbol.eq node1.node_name node2.node_name

   (*
    * Get the node's neighbors.
    *)
   let node_neighbors ra node =
      SymbolTable.fold (fun nodes _ node ->
            match node.node_class with
               NodeStack
             | NodeCoalesced
             | NodeSpilled ->
                  nodes
             | NodePrecolored
             | NodeInitial
             | NodeSimpWL
             | NodeFreezeWL
             | NodeSpillWL
             | NodeColored ->
                  node :: nodes) [] node.node_neighbors

   (*
    * Say if a node is move related.
    *)
   let node_moves node =
      List.filter (fun move ->
            match move.move_class with
               MoveWL
             | MoveActive ->
                  true
             | MoveCoalesced
             | MoveFrozen
             | MoveConstrained ->
                  false) node.node_moves

   (*
    * Get string representation (var) of a node.
    *)
   let var_of_node ra node =
      node.node_name

   let string_of_node ra node =
      string_of_symbol (var_of_node ra node)

   (************************************************************************
    * MOVE OPERATIONS
    ************************************************************************)

   (*
    * Get the list pointer for a node class.
    *)
   let move_worklist ra_moves = function
      MoveCoalesced -> ra_moves.mv_coalesced
    | MoveConstrained -> ra_moves.mv_constrained
    | MoveFrozen -> ra_moves.mv_frozen
    | MoveWL -> ra_moves.mv_wl
    | MoveActive -> ra_moves.mv_active

   (*
    * Get the head of a list.
    *)
   let move_list_head ra cl =
      let l = move_worklist ra cl in
         match !l with
            Some move -> move
          | None -> raise (Invalid_argument "move_list_head")

   (*
    * Iterate through the node list.
    *)
   let move_iter ra cl f =
      let rec iter = function
         Some move ->
            let next = !(move.move_succ) in
               f move;
               iter next
       | None ->
            ()
      in
         iter (!(move_worklist ra cl))

   let move_fold ra cl f x =
      let rec fold x move =
         match move with
            Some move ->
               let next = !(move.move_succ) in
               let x = f x move in
                  fold x next
          | None ->
               x
      in
         fold x (!(move_worklist ra cl))

   (*
    * Create a node in a class.
    *)
   let new_move ra dst src depth cl =
      let l = move_worklist ra cl in
      let next = !l in
      let succ = ref next in
      let node' =
         { move_dst = dst;
           move_src = src;
           move_depth = depth;
           move_class = cl;
           move_pred = l;
           move_succ = succ
         }
      in
      let _ =
         (* Link it into the list *)
         l := Some node';
         match next with
            Some next -> next.move_pred <- succ
          | None -> ()
      in
         ra.mv_list <- node' :: ra.mv_list;
         node'

   (*
    * Reclassify the node.
    *)
   let move_reclassify ra move cl =
      (* Delete the move from its current list *)
      let pred = move.move_pred in
      let succ = !(move.move_succ) in
      let _ =
         pred := succ;
         match succ with
            Some next -> next.move_pred <- pred
          | None -> ()
      in

      (* Add to the new list *)
      let l = move_worklist ra cl in
      let next = !l in
         l := Some move;
         move.move_class <- cl;
         move.move_pred <- l;
         move.move_succ := next;
         match next with
            Some next -> next.move_pred <- move.move_succ
          | None -> ()

   (*
    * Reclassify all the active nodes.
    *)
   let reclassify_active ra =
      move_iter ra MoveActive (fun move ->
            move_reclassify ra move MoveWL)

   (************************************************************************
    * PRINTING
    ************************************************************************)

   (*
    * Print the register allocator state.
    *)
   let print_ra ra =
      node_iter ra NodePrecolored (fun node ->
            let v = var_of_node ra node in
               match node.node_color with
                  Some v' ->
                     eprintf "Precolored: %s->%s@." (string_of_symbol v) (string_of_symbol v')
                | None ->
                     raise (Invalid_argument "Register_alloc.set_colors"));
      node_iter ra NodeInitial (fun node ->
            eprintf "Initial: %s, degree = %d@." (string_of_node ra node) node.node_degree);
      node_iter ra NodeSimpWL (fun node ->
            eprintf "Simp WL: %s, degree = %d@." (string_of_node ra node) node.node_degree);
      node_iter ra NodeFreezeWL (fun node ->
            eprintf "Freeze WL: %s, degree = %d@." (string_of_node ra node) node.node_degree);
      node_iter ra NodeSpillWL (fun node ->
            eprintf "Spill WL: %s, degree = %d@." (string_of_node ra node) node.node_degree);
      node_iter ra NodeSpilled (fun node ->
            eprintf "Spilled: %s, degree = %d@." (string_of_node ra node) node.node_degree);
      node_iter ra NodeCoalesced (fun node ->
            eprintf "Coalesced: %s, degree = %d@." (string_of_node ra node) node.node_degree);
      node_iter ra NodeStack (fun node ->
            eprintf "Stack: %s, degree = %d@." (string_of_node ra node) node.node_degree);
      node_iter ra NodeColored (fun node ->
            let v = var_of_node ra node in
               match node.node_color with
                  Some v' ->
                     eprintf "Colored: %s->%s@." (string_of_symbol v) (string_of_symbol v')
                | None ->
                     raise (Invalid_argument "Register_alloc.set_colors"))

   let print_move move =
      let { move_dst = dst;
            move_src = src;
            move_depth = depth
          } = move
      in
         printf "@[<hv 3>Move:@ dst = %a" pp_print_symbol dst.node_name;
         printf "; expanded = %a" pp_print_symbol (node_alias dst).node_name;
         printf ";@ src = %a" pp_print_symbol src.node_name;
         printf "; expanded = %a" pp_print_symbol (node_alias src).node_name;
         printf "@]"

   (************************************************************************
    * SPILL COST
    ************************************************************************)

   (*
    * Cost of spilling a node.
    *)
   let depth_cost a =
      let len = Array.length a in
      let rec collect cost weight i =
         if i = len then
            cost
         else
            let cost = cost + weight * a.(i) in
            let weight = min max_weight (weight lsl 3) in
               collect cost weight (succ i)
      in
         collect 0 1 0

   let spill_cost stats =
      let { stats_length = length;
            stats_defs = defs;
            stats_uses = uses
          } = stats
      in
      let def_cost = depth_cost defs * Frame.def_cost in
      let use_cost = depth_cost uses * Frame.use_cost in
         length, def_cost, use_cost

   (*
    * Recompute the cost of freezing all moves for this node.
    *)
   let node_move_cost node =
      let node = node_alias node in
      let cost = node.node_move_cost in
         if cost >= 0 then
            cost
         else
            let cost =
               List.fold_left (fun sum move ->
                  let { move_dst = dst;
                        move_depth = depth
                      } = move
                  in
                  let cost =
                     if node_eq node (node_alias dst) then
                        Frame.mov_def_cost
                     else
                        Frame.mov_use_cost
                  in
                  let sum, _ =
                     Array.fold_left (fun (sum, cost) count ->
                           let sum = sum + count * cost in
                           let cost = min max_weight (cost lsl 3) in
                              sum, cost) (0, cost) depth
                  in
                     sum) 0 (node_moves node)
            in
               node.node_move_cost <- cost;
               cost

   (*
    * Recompute the cost of spilling a node.
    *)
   let node_total_cost node =
      let node = node_alias node in
      let cost = node.node_total_cost in
         if cost >= 0 then
            cost
         else
            let { node_total_length = length;
                  node_base_cost = cost;
                  node_degree = degree
                } = node
            in
            let cost =
               if length < Frame.min_spill_length then
                  max_int
               else if degree = 0 then
                  cost
               else
                  cost / (degree * degree)
            in
               node.node_total_cost <- cost;
               cost

   (************************************************************************
    * CLASSIFY NODES
    ************************************************************************)

   (*
    * Create all the nodes.
    *)
   let create_nodes cenv stats ra =
      if !debug_regalloc >= 1 then
         eprintf "Classify nodes@.";
      SymbolTable.mapi (fun v reg_class ->
            let stats = SymbolTable.find stats v in
            let cost = spill_cost stats in
               if is_precolored v then
                  let node = new_node ra v cost NodePrecolored reg_class in
                     node.node_color <- Some v;
                     node
               else
                  new_node ra v cost NodeInitial reg_class) cenv

   (*
    * Create neighbors from adjacency matrix.
    *)
   let create_neighbors ra nodes =
      let edges = ra.ra_edges in

      (* Add a neighbor *)
      let add_neighbor neighbors v1 v2 =
         if is_precolored v1 then
            neighbors
         else
            SymbolTable.filter_add neighbors v1 (fun neighbors ->
                  match neighbors with
                     Some neighbors ->
                        SymbolSet.add neighbors v2
                   | None ->
                        SymbolSet.singleton v2)
      in

      (* Build neighbors list from the adjacency matrix *)
      let neighbors =
         SymSymbolMatrix.fold (fun neighbors v1 v2 _ ->
               let neighbors = add_neighbor neighbors v1 v2 in
               let neighbors = add_neighbor neighbors v2 v1 in
                  neighbors) SymbolTable.empty edges
      in
         (* Convert neighbors to node lists *)
         SymbolTable.iter (fun v neighbors ->
               (* Convert neighbor list to a node list *)
               let node = SymbolTable.find nodes v in
                  if node.node_class <> NodePrecolored then
                     let neighbors =
                        SymbolSet.fold (fun neighbors v ->
                              let node = SymbolTable.find nodes v in
                                 SymbolTable.add neighbors v node) SymbolTable.empty neighbors
                     in
                        node.node_neighbors <- neighbors) neighbors

   (*
    * Compute on the moves.
    *)
   let classify_moves ra nodes moves =
      if !debug_regalloc >= 1 then
         eprintf "Classify moves@.";
      let edges = ra.ra_edges in
         AsymSymbolMatrix.iter (fun dst src { M_ra_type.move_depth = depth } ->
               if not (Lm_symbol.eq dst src) then
                  let dst_node = SymbolTable.find nodes dst in
                  let src_node = SymbolTable.find nodes src in
                  let move = new_move ra dst_node src_node depth MoveWL in
                     dst_node.node_moves <- move :: dst_node.node_moves;
                     src_node.node_moves <- move :: src_node.node_moves) moves

   (*
    * Reclassify all the nodes.
    *)
   let classify_nodes ra =
      if !debug_regalloc >= 1 then
         eprintf "Reclassify nodes@.";
      node_iter ra NodeInitial (fun node ->
            let degree = SymbolTable.cardinal node.node_neighbors in
            let state =
               if degree >= max_colors.(node.node_reg_class) then
                  NodeSpillWL
               else if node_is_move_related node then
                  NodeFreezeWL
               else
                  NodeSimpWL
            in
               node.node_degree <- degree;
               node_reclassify ra node state)

   (*
    * Classify nodes/moves into worklists.
    *)
   let create cenv igraph =
      let { igraph_graph = graph;
            igraph_moves = moves;
            igraph_stats = stats
          } = igraph
      in
      let _ =
         if !debug_regalloc >= 1 then
            eprintf "Register alloc create@."
      in
      let ra =
         { ra_list = [];
           ra_precolored = ref None;
           ra_initial = ref None;
           ra_simp_wl = ref None;
           ra_freeze_wl = ref None;
           ra_spill_wl = ref None;
           ra_spilled = ref None;
           ra_coalesced = ref None;
           ra_colored = ref None;
           ra_stack = ref None;

           mv_list = [];
           mv_coalesced = ref None;
           mv_constrained = ref None;
           mv_frozen = ref None;
           mv_wl = ref None;
           mv_active = ref None;

           ra_edges = graph
         }
      in

      (* Create the node list *)
      let nodes = create_nodes cenv stats ra in

         (* Create the node lists *)
         create_neighbors ra nodes;

         (* Classify all the moves *)
         classify_moves ra nodes moves;

         (* Reclassify all the nodes *)
         classify_nodes ra;

         (* Print it *)
         if !debug_regalloc >= 1 then
            print_ra ra;

         ra

   (************************************************************************
    * UTILITIES
    ************************************************************************)

   (*
    * Enable the moves in the nodes.
    *)
   let enable_moves ra nodes =
      List.iter (fun node ->
            node.node_move_cost <- recompute_cost;
            node.node_total_cost <- recompute_cost;
            List.iter (fun move ->
                  match move.move_class with
                     MoveActive ->
                        move_reclassify ra move MoveWL
                   | _ ->
                        ()) node.node_moves) nodes

   (*
    * Decrement the degree of a node.
    * This may enable some previously blocked moves.
    *)
   let decrement_degree ra node =
      if node.node_class <> NodePrecolored then
         let degree = node.node_degree in
            node.node_total_cost <- recompute_cost;
            node.node_degree <- pred degree;
            if degree = max_colors.(node.node_reg_class) then
               begin
                  enable_moves ra (node :: node_neighbors ra node);
                  if node_is_move_related node then
                     node_reclassify ra node NodeFreezeWL
                  else
                     node_reclassify ra node NodeSimpWL
               end

   (*
    * Query the graph for an edge.
    *)
   let query ra node1 node2 =
      (node1.node_class = NodePrecolored && node2.node_class = NodePrecolored)
      || SymSymbolMatrix.query ra.ra_edges node1.node_name node2.node_name

   (*
    * Add a neighbor relationship.
    *)
   let add_neighbor node1 node2 =
      let name2 = node2.node_name in
         assert (not (SymbolTable.mem node1.node_neighbors name2));
         node1.node_total_cost <- recompute_cost;
         node1.node_neighbors <- SymbolTable.add node1.node_neighbors name2 node2;
         node1.node_degree <- succ node1.node_degree

   (*
    * Add a node to a worklist.
    *)
   let add_worklist ra node =
      match node.node_class with
         NodeFreezeWL
       | NodeSpillWL
         when (not (node_is_move_related node) && node.node_degree < max_colors.(node.node_reg_class)) ->
            if !debug_regalloc >= 2 then
               eprintf "add_worklist: %s[%s]@." (string_of_symbol node.node_name) (string_of_node_class node.node_class);
            node_reclassify ra node NodeSimpWL
       | _ ->
            ()

   (************************************************************************
    * SIMPLIFY
    ************************************************************************)

   (*
    * Simplify.
    *)
   let simplify ra =
      if !debug_regalloc >= 1 then
         eprintf "Simplify@.";
      let node1 = node_list_head ra NodeSimpWL in
         node_reclassify ra node1 NodeStack;
         List.iter (fun node2 ->
               assert (not (node_eq node2 node1));
               decrement_degree ra node2) (node_neighbors ra node1)

   (************************************************************************
    * COALESCE
    ************************************************************************)

   (*
    * George test.
    *)
   let george_test ra u v =
      let max_colors = max_colors.(u.node_reg_class) in
      let ok t =
         t.node_degree < max_colors
         || (t.node_class = NodePrecolored)
         || query ra t u
      in
         List.for_all ok (node_neighbors ra v)

   (*
    * Briggs test.
    *)
   let briggs_test ra u v =
      let max_colors = max_colors.(u.node_reg_class) in
      let collect (nodes, i) node =
         if i = max_colors then
            nodes, i
         else
            let name = node.node_name in
               if SymbolSet.mem nodes name then
                  nodes, i
               else
                  let nodes = SymbolSet.add nodes name in
                     if node.node_degree >= max_colors then
                        nodes, succ i
                     else
                        nodes, i
      in
      let nodes, k = List.fold_left collect (SymbolSet.empty, 0) (node_neighbors ra u) in
         if k < max_colors then
            let nodes, k = List.fold_left collect (SymbolSet.empty, k) (node_neighbors ra v) in
               k < max_colors
         else
            false

   (*
    * Colored test allows george.
    *)
   let colored_test ra u v =
      george_test ra u v

   (*
    * Noncolored test allow briggs or george.
    *)
   let noncolored_test ra u v =
      george_test ra u v || george_test ra v u || briggs_test ra u v

  (*
    * Copy an edge in the graph, adding it between u and v.
    *)
   let add_edge ra u v =
      let name_u = u.node_name in
      let name_v = v.node_name in
         if not (SymSymbolMatrix.query ra.ra_edges name_u name_v) then
            begin
               SymSymbolMatrix.add ra.ra_edges name_u name_v true;
               if u.node_class <> NodePrecolored then
                  add_neighbor u v;
               if v.node_class <> NodePrecolored then
                  add_neighbor v u
            end

   (*
    * Combine the MOV lists.
    * Prune duplicate moves.
    *)
   let combine_moves moves1 moves2 =
      let collect (table, moves) move =
         let { move_dst = u;
               move_src = v
             } = move
         in
         let u = node_alias u in
         let v = node_alias v in
         let u = u.node_name in
         let v = v.node_name in
         let cmp = Lm_symbol.compare u v in
            if cmp = 0 then
               table, moves
            else
               let p =
                  if cmp < 0 then
                     u, v
                  else
                     v, u
               in
                  if MoveSet.mem table p then
                     table, moves
                  else
                     let moves = move :: moves in
                     let table = MoveSet.add table p in
                        table, moves
      in
      let table, moves = List.fold_left collect (MoveSet.empty, []) moves1 in
      let table, moves = List.fold_left collect (table, moves) moves2 in
         moves

   (*
    * Combine two nodes.
    * Add their costs, and combine the neighbor lists.
    *)
   let combine_normal ra move u v =
      let neighbors = node_neighbors ra u in
      let dump_neighbors_list msg t =
         if !debug_regalloc >= 2 then begin
            eprintf "   interference node %s %s@." msg (string_of_symbol t.node_name);
            eprintf "      neighbors:";
            SymbolTable.iter (fun _ x -> eprintf " %s" (string_of_symbol x.node_name)) t.node_neighbors;
            eprintf "@.";
         end
      in
         if !debug_regalloc >= 1 then
            begin
               eprintf "Coalescing nodes (normal) %s[degree=%d,length=%d]->%s[degree=%d,length=%d]@." (**)
                  (string_of_node ra u) u.node_degree u.node_total_length
                  (string_of_node ra v) v.node_degree v.node_total_length;
               eprintf "neighbors:";
               List.iter (fun v ->
                     eprintf " %s" (string_of_symbol v.node_name)) neighbors;
               eprintf "@.";
            end;
         v.node_move_cost <- recompute_cost;
         v.node_total_cost <- recompute_cost;
         v.node_base_cost <- u.node_base_cost + v.node_base_cost;
         v.node_moves <- combine_moves u.node_moves v.node_moves;
         v.node_total_length <- u.node_total_length + v.node_total_length;
         assert (not (Lm_symbol.eq u.node_name v.node_name));
         List.iter (fun t ->
               assert (not (Lm_symbol.eq v.node_name t.node_name));
               dump_neighbors_list "before copy_edge" t;
               add_edge ra v t;
               dump_neighbors_list "after copy_edge" t;
               decrement_degree ra t) neighbors;
         node_reclassify ra u NodeCoalesced;
         u.node_alias <- Some v;
         if v.node_degree >= max_colors.(v.node_reg_class) && v.node_class = NodeFreezeWL then
            node_reclassify ra v NodeSpillWL

   (*
    * Combining precolored nodes is simpler because we
    * don't have to worry about spill costs or maintaining the
    * neighbor lists.
    *)
   let combine_precolored ra u v =
      let neighbors = node_neighbors ra v in
         if !debug_regalloc >= 1 then
            eprintf "Coalescing nodes (precolored) %s<-%s@." (**)
               (string_of_node ra u) (string_of_node ra v);
         List.iter (fun t ->
               add_edge ra u t;
               decrement_degree ra t) neighbors;
         node_reclassify ra v NodeCoalesced;
         v.node_alias <- Some u

   (*
    * Coalesce.
    *)
   let coalesce ra =
      if !debug_regalloc >= 1 then
         eprintf "Coalesce@.";
      let move = move_list_head ra MoveWL in
      let x = node_alias move.move_dst in
      let y = node_alias move.move_src in
      let u, v =
         if y.node_class = NodePrecolored then
            y, x
         else
            x, y
      in
         if node_eq u v then
            begin
               if !debug_regalloc >= 2 then
                  eprintf "Already coalesced: %s@." (string_of_symbol u.node_name);
               move_reclassify ra move MoveCoalesced;
               v.node_move_cost <- recompute_cost;
               u.node_total_cost <- recompute_cost;
               add_worklist ra u
            end
         else if v.node_class = NodePrecolored || query ra u v then
            begin
               if !debug_regalloc >= 2 then
                  eprintf "Constrained: %s<->%s@." (string_of_symbol u.node_name) (string_of_symbol v.node_name);
               move_reclassify ra move MoveConstrained;
               add_worklist ra u;
               add_worklist ra v
            end
         else if u.node_class = NodePrecolored && colored_test ra u v then
            begin
               move_reclassify ra move MoveCoalesced;
               combine_precolored ra u v
            end
         else if u.node_class <> NodePrecolored && noncolored_test ra u v then
            begin
               move_reclassify ra move MoveCoalesced;
               combine_normal ra move u v;
               add_worklist ra v
            end
         else
            move_reclassify ra move MoveActive

   (************************************************************************
    * FREEZE AND SPILL
    ************************************************************************)

   (*
    * Compare two nodes based on spill cost.
    *)
   let compare_move_cost node1 node2 =
      node_move_cost node1 < node_move_cost node2

   let compare_total_cost node1 node2 =
      node_total_cost node1 < node_total_cost node2

   (*
    * Freeze the moves for a node.
    *)
   let freeze_moves ra node =
      let u = node_alias node in
      let moves = node_moves node in
         u.node_move_cost <- recompute_cost;
         u.node_total_cost <- recompute_cost;
         List.iter (fun move ->
               let y = node_alias move.move_src in
               let v =
                  if node_eq y u then
                     node_alias move.move_dst
                  else
                     y
               in
                  move_reclassify ra move MoveFrozen;
                  if not (node_is_move_related v)
                     && v.node_class <> NodePrecolored
                     && v.node_degree < max_colors.(v.node_reg_class)
                  then
                     node_reclassify ra v NodeSimpWL) moves

   (*
    * Select a node for spilling.
    *)
   let freeze_best compare ra vars cl =
      let better_node best node2 =
         if SymbolTable.mem vars node2.node_name then
            match best with
               Some node1 ->
                  if compare node1 node2 then
                     best
                  else
                     Some node2
             | None ->
                  Some node2
         else
            best
      in
      let rec search best node =
         let node = node_alias node in
         let best = better_node best node in
            if !debug_regalloc >= 1 then
               begin
                  let v = var_of_node ra node in
                     eprintf "Searching: %s [cost=%d,degree=%d]@." (string_of_symbol v) (node_total_cost node) node.node_degree;
                     eprintf "\tNeighbors:";
                     List.iter (fun node -> eprintf " %s" (string_of_symbol (var_of_node ra node))) (node_neighbors ra node);
                     eprintf "@."
               end;
            if node_has_no_succ node then
               best
            else
               search best (node_succ node)
      in
         match search None (node_list_head ra cl) with
            Some node ->
               if !debug_regalloc >= 1 then
                  eprintf "Selected: %s@." (string_of_symbol (var_of_node ra node));
               node_reclassify ra node NodeStack;
               List.iter (fun node2 ->
                     assert (not (Lm_symbol.eq node.node_name node2.node_name));
                     decrement_degree ra node2) (node_neighbors ra node);
               freeze_moves ra node
          | None ->
               raise (Invalid_argument "spill: no spillable vars")

   (*
    * Freeze.
    *)
   let freeze ra vars =
      if !debug_regalloc >= 1 then
         eprintf "Freeze@.";
      freeze_best compare_move_cost ra vars NodeFreezeWL

   (*
    * Spill.
    *)
   let spill ra vars =
      if true || !debug_regalloc >= 1 then
         eprintf "Spill@.";
      freeze_best compare_total_cost ra vars NodeSpillWL

   (************************************************************************
    * SELECT
    ************************************************************************)

   (*
    * When choosing a color, try to choose a color
    * that still does coalescing.
    *)
   let choose_color node colors =
      let node = node_alias node in
      let rec search moves =
         match moves with
            move :: moves ->
               (match move.move_class with
                   MoveWL
                 | MoveActive
                 | MoveFrozen ->
                      let u = node_alias move.move_dst in
                      let u =
                         if node_eq u node then
                            node_alias move.move_src
                         else
                            u
                      in
                         (match u with
                             { node_class = NodeColored; node_color = Some color }
                           | { node_class = NodePrecolored; node_color = Some color }
                             when SymbolSet.mem colors color ->
                                color
                           | _ ->
                                search moves)
                 | MoveCoalesced
                 | MoveConstrained ->
                      search moves)
          | [] ->
               SymbolSet.choose colors
      in
      let color = search node.node_moves in
         node.node_color <- Some color

   (*
    * Assign colors to the nodes in the stack.
    *)
   let rec assign_colors ra =
      if !debug_regalloc >= 1 then
         eprintf "Assign colors@.";
      node_iter ra NodeStack (fun node ->
         let remove_color colors w =
            let w' = node_alias w in
               match w'.node_class with
                  NodeColored
                | NodePrecolored ->
                     (match w'.node_color with
                         Some color ->
                            if !debug_regalloc >= 1 then
                               begin
                                  eprintf "\tNeighbor %s is colored %s@." (**)
                                     (string_of_symbol (var_of_node ra w'))
                                     (string_of_symbol color)
                               end;
                            SymbolSet.remove colors color
                       | None ->
                            raise (Invalid_argument "assign_colors"))
                | _ ->
                     if !debug_regalloc >= 1 then
                        begin
                           eprintf "\tNeighbor %s is not colored yet@." (**)
                              (string_of_symbol (var_of_node ra w'));
                        end;
                     colors
         in
            if !debug_regalloc >= 1 then
               eprintf "Choosing color for %s@." (string_of_symbol (var_of_node ra node));
            let colors = registers.(node.node_reg_class) in
            let colors =
               SymbolTable.fold (fun colors _ node ->
                     remove_color colors node) colors node.node_neighbors
            in
               if SymbolSet.is_empty colors then
                  begin
                     if !debug_regalloc >= 1 then
                        eprintf "Spilled %s@." (string_of_symbol (var_of_node ra node));
                     node_reclassify ra node NodeSpilled
                  end
               else
                  begin
                     choose_color node colors;
                     node_reclassify ra node NodeColored
                  end)

   (*
    * Assign colors to the spilled nodes.
    *)
   let rec assign_spill_colors rclass ra spset =
      if !debug_regalloc >= 1 then
         eprintf "Assign spill colors: %d@." rclass;

      (* Generate spills *)
      let spilled =
         node_fold ra NodeSpilled (fun spset node ->
            if node.node_reg_class = rclass then
               SymbolSet.add spset (var_of_node ra node)
            else
               spset) SymbolSet.empty
      in

      (* Spill only those with long live ranges *)
      let spset =
         node_fold ra NodeSpilled (fun spset node ->
               if node.node_length > Frame.min_spill_length then
                  SymbolSet.add spset (var_of_node ra node)
               else
                  spset) spset
      in
         (* Also spill any nodes that alias to these *)
         node_fold ra NodeCoalesced (fun spset node ->
               let node' = node_alias node in
               let v' = var_of_node ra node' in
                  if node.node_length > Frame.min_spill_length && SymbolSet.mem spilled v' then
                     SymbolSet.add spset (var_of_node ra node)
                  else
                     spset) spset

   (*
    * Spill all the variables of each class.
    *)
   let assign_spill_colors ra =
      let rec collect spset i =
         if i = Frame.reg_class_count then
            spset
         else
            collect (assign_spill_colors i ra spset) (succ i)
      in
         collect SymbolSet.empty 0

   (*
    * Add all the colored nodes to the spset.
    *)
   let set_colors ra =
      if !debug_regalloc >= 1 then
         print_ra ra;

      (* Empty spset *)
      let spset = SymbolTable.empty in

      (* Add all the coalesced nodes *)
      let spset =
         node_fold ra NodeCoalesced (fun spset node ->
               let v = var_of_node ra node in
                  match node.node_alias with
                     Some node ->
                        SymbolTable.add spset v (var_of_node ra node)
                   | None ->
                        raise (Invalid_argument "Register_alloc.set_colors")) spset
      in
         (* Add all the colored nodes *)
         node_fold ra NodeColored (fun spset node ->
               let v = var_of_node ra node in
                  match node.node_color with
                     Some v' ->
                        SymbolTable.add spset v v'
                   | None ->
                        raise (Invalid_argument "Register_alloc.set_colors")) spset

   (*
    * Add all the moves to the spset.
    *)
   let add_moves spset ra =
      if !debug_regalloc >= 1 then
         print_ra ra;

      (* Add all the coalesced nodes *)
      node_fold ra NodeCoalesced (fun spset node ->
            let v = var_of_node ra node in
               match node.node_alias with
                  Some node ->
                     SymbolTable.add spset v (var_of_node ra node)
                | None ->
                     raise (Invalid_argument "Register_alloc.set_colors")) spset

   (************************************************************************
    * MAIN PROGRAM
    ************************************************************************)

   (*
    * Worklists tests.
    *)
   let simp_not_done ra =
      !(ra.ra_simp_wl) <> None

   let move_not_done ra =
      !(ra.mv_wl) <> None

   let freeze_not_done ra =
      !(ra.ra_freeze_wl) <> None

   let spill_not_done ra =
      !(ra.ra_spill_wl) <> None

   let spilled_nodes ra =
      !(ra.ra_spilled) <> None

   let move_freeze_not_done ra =
      !(ra.mv_frozen) <> None

   let coalesce_not_done ra =
      move_fold ra MoveCoalesced (fun i _ -> succ i) 0 > 5

   (*
    * Main program performs the algorithm on page 244.
    *)
   let compile blocks =
      if !debug_regalloc >= 1 then
         begin
            eprintf "Register_alloc.main@.";
            Frame.pp_print_inst_blocks err_formatter blocks
         end;

      (* Get the vars in the program *)
      let vars = Frame.vars_blocks blocks in

      (* Generate interference graph *)
      let igraph = Liveness.create_graph vars all_special blocks in

      (* Classify nodes into worklists *)
      let ra = create vars igraph in

      (* Loop until all worklists are empty *)
      let rec loop () =
         if simp_not_done ra then
            begin
               simplify ra;
               ra_check "simplify2" ra;
               loop ()
            end
         else if move_not_done ra then
            begin
               coalesce ra;
               ra_check "coalesce2" ra;
               loop ()
            end
         else if freeze_not_done ra then
            begin
               freeze ra vars;
               ra_check "freeze2" ra;
               loop ()
            end
         else if spill_not_done ra then
            begin
               spill ra vars;
               ra_check "spill2" ra;
               loop ()
            end
      in
      let _ = loop () in
         assign_colors ra;

         (* Check if there were spills *)
         if spilled_nodes ra then
            RegAllocSpill (assign_spill_colors ra)
         else
            (* There are no spills, return the substitution *)
            RegAllocColor (set_colors ra)
end

let () = std_flags_help_section_text "ra.debug"
   "Debugging flags for the register allocator."

let () = std_flags_register_list_help "ra.debug"
  ["ra.debug.enable_coalescing",    FlagBool true,
                                    "Enable register coalescing.  This is a very good idea in general," ^
                                    " and should only be disabled during certain types of RA debugging.";
   "ra.debug.always_copy_edge",     FlagBool true,
                                    "Invoke copy_edge during coalescing for all neighbor classes.  See" ^
                                    " the warnings in RA before modifying this flag.  Warning: if this" ^
                                    " flag is false, then RA is susceptible to the symbol order bug!"]

(*
 * -*-
 * Local Variables:
 * Caml-master: "compile"
 * End:
 * -*-
 *)
