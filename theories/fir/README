Mojave FIR Theory
README
by Brian Emre Aydemir (emre@cs.caltech.edu)


I have made every attempt to document the Mojave FIR theory.  A great
majority of the documentation can be found in the theories.pdf file
generated by running ``make latex''.  Additional documentation can
be found in scattered comments and the BUGS file.

Each of the modules in this theory is described briefly below.

   Basic modules:
   -  Mfir_auto:     Contains mechanisms to automate the FIR theory.
   -  Mfir_bool:     A (purely syntactic?) implementation of booleans.
   -  Mfir_token:    A purely syntactic representation of strings.
   -  Mfir_record:   A (purely syntactic?) implmentation of records.
   -  Mfir_int:      A (purely syntactic?) implementation of infinite
                     precision integers.
   -  Mfir_list:     A (purely syntactic?) implementation of lists.
   -  Mfir_int_set:  A (purely syntactic?) implementation of sets of integers.

   Core term declarations:
   -  Mfir_ty:       Declares terms to represent the FIR type system.
   -  Mfir_exp:      Declares terms to represent FIR operators and expressions.
   -  Mfir_sequent:  Declares terms used in representing FIR programs
                     as sequents.
   -  Mfir_util:     Declares terms and rewrites for manipulating FIR
                     expressions and types.

   Typing rules:
   -  Mfir_tr_base:  Defines basic typing rules.
   -  Mfir_tr_types: Defines well-formedness for FIR types.
   -  Mfir_tr_atom_base:   Defines macros to get the argument types and
                     result type of the FIR unary and binary operators.
   -  Mfir_tr_atom:  Defines the typing relations for FIR atoms.
   -  Mfir_tr_store: Defines the typing relations for store values in the FIR.
   -  Mfir_tr_exp:   Defines the typing relations for FIR expressions.


---------------------------------------------------------------------------


The following remarks by Brian Emre Aydemir (emre) are intended to
serve as notes to himself.  They may not make sense to others.

-- Sequent idea notes:
   1. A sequent to reason about programs (which are sequents):
         gamma_1 |- sequent { gamma_2; v : t = h |- dot } wf
   2. gamma_2 above has the following syntax:
         gamma ::=   empty
                |    gamma, v : Type
                |    gamma, v : Variable
                |    ...
                |    gamma, v : t      (implicit dummy label here)
                |    gamma, v : t = h  (implicit dummy label here)
                |    ...
   3. gamma_1 above may contain things like (f: A -> B), i.e. the
      program (sequent) is quantified over f.

-- I need to decide how to automate all the rules.  I'm not quite sure
   if adding them to the intro/elimination resources is the best thing
   to do.  Likewise, I should check whether or not things being added
   to the auto tactic are being added ``intelligently''.


Notable differences from the actual Mojave FIR:

-- The following have been ``curried'' (since: lists are somewhat annoying
   to deal with in MetaPRL, can get better binding structure, ...):
      TyFun
      TyAll
      TyExists
      TyDefUnion  (using tyDefPoly)
      TyDefLambda (using tyDefPoly)
      frames      (using tyDefPoly)

-- The actual FIR specification (mcc/fir/type/fir.ml) has terms
   whose subterms are (ML) lists.  In some cases, if these lists are
   empty, the term is degenerate in some sense, e.g TyExists ([], t).
   For my own sanity, I'm not going to consider such degenerate terms,
   and instead, I will assume everything is in a normalized form.
   The way I've declared terms, may degenerate terms cannot be
   represented in their degenerate form.

-- No term is declared for TyDelayed.  This is intentional, since we
   we do not plan on formalizing type inference in the near future.

-- No term is declared for AtomFun.  I am pretty sure that
   it is not needed.

-- No terms are declared for debugging info in the FIR.
   This info has no semantic content.


Comments that will be around a while:

-- Display forms will be implmented with the philosophy, ``if it works for
   me, it must be good enough''.

-- Must _not_ include anything from ITT.  Otherwise, we get
   a soup of logical inconsistencies/differences.  Alternatively,
   we can use ITT, but we have to think it through carefully.

-- MetaPRL theories are open, so we can not do induction over a set of
   rules.  In particular, there's no way we can formalize the proofs
   of the technical report without going through some trouble.
