Notes as of 6 October 2001 (I hope...):

(When I say FIR, I refer to the FIR in the mc compiler.)

In general, the Fir_type* modules need testing and refinement
at this point.  Emphasis on the testing.  I've just sort
of guessed what typing judgements are useful/correct.  There's
no actual guarentees that the type system defined through those files
is consistent, logical, correct, etc.  There's no guarentee that they
even make any sort of sense at this point.

The general divisions for the Fir_type* files are as follows:
Fir_type : basic types, e.g. Fir_ty
Fir_type_exp : rules for Fir_exp stuff
Fir_type_int : rules for Fir_int stuff (mostly a convinience for automation
   last I checked)

The rest of the files are intended to represent the following:
Fir_int_set : A limited implementation of the int_set's in the FIR.
   The set is essentially a list of closed intervals over the integers.
   Unlike the FIR, I have no notiong of max / min sets, singleton sets,
   and all those convinient operations/representations.  I have a list
   of intervals, I can test for membership, and that's about it.
   I don't even try enforcing that the intervals are in any sort of sane
   order or that for a given interval [a,b], I don't enforce a<=b
   (though membership testing should blow up badly if that's the case).
Fir_ty : FIR types
Fir_exp : FIR expressions
Fir_eval : used to evaluate the FIR as output by mc with -print_metaprl.

Oh yeah, naming scheme.  Essentially, anything that's supposed to represent
something in the fir uses the exact same name, except the first
character is lowercase, e.g. TyInt -> tyInt.

With term names like these, the idea is that the mc compiler
can easily spit things out with a minimum of mangling, leaving it
to MetaPRL to provide the necessary rewrites to change the output
or whatever into something it can deal with.

This seems to work pretty well.

The only oddity at this point is that tuples are being represented
here (and emmited by the compiler) as lists it would seem.
Really wacky if you ask me, but umm, well, this all has to do with...

Subscripting.  Subscripting is fun.  Subscripting is interesting.  Yes.
So are union related things. These are all "fun".  That means that
I don't feel that I completely understand them yet, so their implementation
and whatnot may be wacky.
