(*
 * A remote processor manages remote execution.
 * Jobs can be taken from and submitted to the global queue.
 *
 * ----------------------------------------------------------------
 *
 * This file is part of MetaPRL, a modular, higher order
 * logical framework that provides a logical programming
 * environment for OCaml and other languages.
 *
 * See the file doc/index.html for information on Nuprl,
 * OCaml, and more information about this system.
 *
 * Copyright (C) 1998 Jason Hickey, Cornell University
 * 
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; either version 2
 * of the License, or (at your option) any later version.
 * 
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
 * 
 * Author: Jason Hickey
 * jyh@cs.cornell.edu
 *)

module type RemoteSig =
sig
   (************************************************************************
    * TYPES                                                                *
    ************************************************************************)

   (*
    * A remote process manager.
    *    'a: the argument type
    *    'b: the result type
    *)
   type ('a, 'b) t

   (*
    * Each sub-job is identified by a handle.
    *)
   type ('a, 'b) handle

   (*
    * A handle to a job being served locally.
    *)
   type ('a, 'b) local

   (*
    * We provide a new version of the scheduler
    * on these events.
    *)
   type 'a event

   (*
    * These are the possible responses to
    * a job.  The RemoteCanceled may be returned
    * if the job was canceled, but it is not required.
    * If the job was not canceled, the Cancel event is
    * never returned.
    *)
   type 'b response =
      RemoteCanceled
    | RemoteSuccess of 'b

   (************************************************************************
    * REMOTE SCHEDULER                                                     *
    ************************************************************************)

   (*
    * Create a new remote manager.
    * At creation time it contains no pending jobs.
    *)
   val create : unit -> ('a, 'b) t

   (*
    * Submit a job to be run remotely.
    *)
   val submit : ('a, 'b) t -> 'a -> ('a, 'b) handle

   (*
    * Get the return event for the handle.
    * This event returns at most one message.
    *)
   val event_of_handle : ('a, 'b) t -> ('a, 'b) handle -> 'b event

   (*
    * Cancel a remote job.  After this, the handle and
    * it event can be discarded.
    *)
   val cancel_handle : ('a, 'b) t -> ('a, 'b) handle -> unit

   (*
    * Request a job from the server.
    * This event can be used at any time
    * to request a remote job.
    *)
   val request : ('a, 'b) t -> ('a, 'b) local event

   (*
    * Event for a local job.
    * This event has at most two messages on it.
    * The first message is always (RemoteSuccess x),
    * where x is the argument to be evaluated.
    * The second event, if it occurs, is a RemoteCancel
    * event if the local job should be terminated.
    *)
   val event_of_local : ('a, 'b) t -> ('a, 'b) local -> 'b response event

   (*
    * Cancel the service for a local job.
    * The local job can be canceled at any time, and it
    * will be restarted automatically.  After this,
    * the local event can be discarded.
    *)
   val cancel_local : ('a, 'b) t -> ('a, 'b) local -> unit

   (*
    * Return a result for a local job.  After the result
    * is returned, the local job can be discarded.
    *)
   val return_local : ('a, 'b) t -> ('a, 'b) local -> 'b -> unit

   (************************************************************************
    * SCHEDULING                                                           *
    ************************************************************************)

   (*
    * Wrap an event.
    *)
   val wrap : 'a event -> ('a -> 'b) -> 'b event

   (*
    * Wrap a regular event.
    *)
   val wrap_event : 'a Thread_event.event -> 'a event

   (*
    * Scheduling.
    *)
   val select : 'a event list -> 'a
end

(*
 * -*-
 * Local Variables:
 * Caml-master: "refiner"
 * End:
 * -*-
 *)
