(*
 * Define a common tactic type.
 *
 * We build tactics as a layer over the refiner,
 * and the tactics are summarized using Tactic_cache.extract.
 *
 * Eventually, it would be desirable to have tactics just
 * manipulate the Tactic_cache.extract, and perform all
 * search outside the refiner.  Then once the search is
 * complete, the extract would be generated by the refiner.
 *
 * For now, this is too hard.  We use the refiner to guide the
 * search, and we keep the extract up-to-date with the
 * current refinement.  This allows is to use chaining while
 * retaining the traditional search mechanisms.
 *
 * A tactic has two parts:
 *    1. It contains a Refine.tactic
 *
 * ----------------------------------------------------------------
 *
 * This file is part of MetaPRL, a modular, higher order
 * logical framework that provides a logical programming
 * environment for OCaml and other languages.
 *
 * See the file doc/index.html for information on Nuprl,
 * OCaml, and more information about this system.
 *
 * Copyright (C) 1998 Jason Hickey, Cornell University
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; either version 2
 * of the License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
 *
 * Author: Jason Hickey
 * jyh@cs.cornell.edu
 *)

open Mp_debug
open Printf
open Thread_util

open Opname
open Refiner.Refiner
open Refiner.Refiner.Term
open Refiner.Refiner.TermMan
open Refiner.Refiner.TermAddr
open Refiner.Refiner.TermSubst
open Refiner.Refiner.RefineError
open Refiner.Refiner.Refine

open Theory

(*
 * Show that the file is loading.
 *)
let _ =
   if !debug_load then
      eprintf "Loading Tactic_type%t" eflush

let debug_tactic =
   create_debug (**)
      { debug_name = "tactic";
        debug_description = "display primitive tactic operations";
        debug_value = false
      }

let debug_refine = load_debug "refine"

(************************************************************************
 * TYPES                                                                *
 ************************************************************************)

(*
 * An extract may be precomputed,
 * or it may be a closure to product the extract.
 * We also make the identity be a special case because it
 * happens so often, and we want to prune it from
 * the resulting extract.
 *)
type extract =
   Extract of Refine.extract * int
 | Compose of extract * extract list
 | Identity

(*
 * Build the thread refiner.
 *)
module ThreadRefinerArg =
struct
   (* Have to do this to avoid type recursion *)
   type extract_aux = extract
   type extract = extract_aux

   let identity = Identity
   let compose ext extl = Compose (ext, extl)
end

module ThreadRefinerTacticals = Thread_refiner.ThreadRefinerTacticals
module ThreadRefinerAux = Thread_refiner.MakeThreadRefiner (ThreadRefinerArg)

(*
 * We have to create explicit function points to get the marshaler to
 * work correctly (Without marshaling the entire ThreadRefiner).
 *)
module ThreadRefiner =
struct
(*
   let args = ThreadRefinerAux.args
   let create = ThreadRefinerAux.create
   let eval = ThreadRefinerAux.eval
   let compose1 = ThreadRefinerAux.compose1
   let compose2 = ThreadRefinerAux.compose2
   let composef = ThreadRefinerAux.composef
   let first = ThreadRefinerAux.first
   let main_loop = ThreadRefinerAux.main_loop
*)
   let arg_of_key = ThreadRefinerAux.arg_of_key
   let share = ThreadRefinerAux.share
   let create_value = ThreadRefinerAux.create_value
end

(*
 * Conversions are used by the rewrite module.
 *)
type env = tactic_arg * address

and conv =
   RewriteConv of rw
 | CondRewriteConv of cond_rewrite
 | ComposeConv of conv Flist.t
 | ChooseConv of conv Flist.t
 | AddressConv of address * conv
 | FoldConv of term * conv
 | CutConv of term
 | FunConv of (env -> conv)
 | HigherConv of conv
 | IdentityConv

(*
 * Many tactics wish to examine their argument, so
 * the real type of tactic includes an argument.
 *)
and 'term attribute =
   TermArg of 'term
 | TypeArg of 'term
 | IntArg of int
 | BoolArg of bool
 | SubstArg of 'term

and 'a attributes = (string * 'a attribute) list

(*
 * The attribute calculations are delayed to minimize communication
 * cost.  The tactic_arg uses keys to distribute the attributes.
 * The values are stored in keys.
 *)
and shared_object =
   ShareConv of conv
 | ShareTactic of tactic
 | ShareIntTactic of (int -> tactic)
 | ShareArgTactic of (tactic_arg -> tactic)
 | ShareTSubst of (term_subst -> (string option * term) -> term_subst)
 | ShareTypeinf of (unify_subst -> term -> unify_subst * term)
 | ShareSentinal of Refine.sentinal
 | ShareCache of cache_info ref

and shared_key = shared_object ThreadRefinerAux.key

(*
 * The raw attributes refer to the shared objects.
 *)
and raw_attribute_val =
   RawTermArg of term
 | RawTypeArg of term
 | RawIntArg of int
 | RawBoolArg of bool
 | RawSubstArg of term
 | RawObjectArg of shared_key

and raw_attribute = string * raw_attribute_val
and raw_attributes = raw_attribute list

(*
 * Every goal has:
 *   ref_goal: the msequent that is to be proved
 *   ref_label: a label (typically "main") that is used to deescribe the goal
 *   ref_attributes: other attributes that provide info to the tactics
 *   ref_cache: the Tactic_cache.extract that represents this goal
 *   ref_rsrc: the resources that are threaded through the refinement
 *
 *   To increase efficiency, the cache is computed lazily.
 *
 *   The sentinal is an index into a sentinal array.
 *)
and tactic_arg =
   { ref_goal : msequent;
     ref_label : string;
     ref_attributes : raw_attributes;
     mutable ref_cache : shared_key;
     ref_sentinal : shared_key
   }

and sentinal = shared_key

(*
 * The cache is current, or it may be out-of-date.
 *)
and cache_info =
   Current of cache
 | OutOfDate of cache

(*
 * The cache is instantiated with tactic
 * justifications.  This may change at some
 * point.
 *)
and cache        = tactic Tactic_cache.extract
and raw_cache    = shared_key

(*
 * A tactic_value is a list of subgoals, and a means for
 * computing the extract.
 *)
and pre_tactic   = prim_tactic
and tactic_value = tactic_arg ThreadRefinerAux.t
and tactic       = tactic_arg -> tactic_value

(************************************************************************
 * IMPLEMENTATION                                                       *
 ************************************************************************)

(*
 * Server is created at file execution time.
 *)
let print_tactic_arg out { ref_goal = goal } =
   let goal, _ = dest_msequent goal in
   let goal = TermMan.nth_concl goal 0 in
      debug_print out goal

let args = ThreadRefinerAux.args

let remote_server = Register.set 0 (ThreadRefinerAux.create print_tactic_arg)

let get_remote_server () =
   Register.get remote_server

(*
 * Create an initial tactic_arg for a proof.
 * Cache is initially out-of-date.  It will be
 * set to the current goal when requested.
 *)
let create sentinal label goal cache attributes =
   { ref_goal = goal;
     ref_label = label;
     ref_attributes = attributes;
     ref_cache = cache;
     ref_sentinal = sentinal
   }

let main_loop () =
   ThreadRefinerAux.main_loop (get_remote_server ())

(*
 * Access to the sequent.
 *)
let msequent { ref_goal = seq } =
   seq

let goal { ref_goal = goal } =
   fst (dest_msequent goal)

let nth_hyp { ref_goal = goal } i =
   TermMan.nth_hyp (fst (dest_msequent goal)) i

let nth_concl { ref_goal = goal } i =
   TermMan.nth_concl (fst (dest_msequent goal)) i

let label { ref_label = label } =
   label

(*
 * Modify the argument.
 *)
let set_goal arg goal =
   let { ref_goal = seq;
         ref_label = label;
         ref_attributes = attributes;
         ref_cache = cache;
         ref_sentinal = sentinal
       } = arg
   in
      { ref_goal = mk_msequent goal (snd (dest_msequent seq));
        ref_label = label;
        ref_attributes = attributes;
        ref_cache = cache;
        ref_sentinal = sentinal
      }

let set_concl arg concl =
   let { ref_goal = seq;
         ref_label = label;
         ref_attributes = attributes;
         ref_cache = cache;
         ref_sentinal = sentinal
       } = arg
   in
   let goal, hyps = dest_msequent seq in
      { ref_goal = mk_msequent (replace_goal goal concl) hyps;
        ref_label = label;
        ref_attributes = attributes;
        ref_cache = cache;
        ref_sentinal = sentinal
      }

let set_label arg label =
   let { ref_goal = goal;
         ref_attributes = attributes;
         ref_cache = cache;
         ref_sentinal = sentinal
       } = arg
   in
      { ref_goal = goal;
        ref_label = label;
        ref_attributes = attributes;
        ref_cache = cache;
        ref_sentinal = sentinal
      }

(************************************************************************
 * SENTINAL                                                             *
 ************************************************************************)

(*
 * Sentinal function is lazy.
 *)
let get_theory name =
   let rec search = function
      thy :: t ->
         if thy.thy_name = name then
            thy
         else
            search t
    | [] ->
         raise (RefineError ("get_theory", StringStringError ("theory is not found", name)))
   in
      search (get_theories ())

let sentinal_of_refiner mod_name =
   let lazy () =
      let refiner = (get_theory mod_name).thy_refiner in
         ShareSentinal (Refine.sentinal_of_refiner refiner)
   in
      ThreadRefiner.share (get_remote_server ()) "sentinal" lazy

let sentinal_of_refiner_object mod_name name =
   let lazy () =
      let refiner = (get_theory mod_name).thy_refiner in
      let opname = make_opname [name; mod_name] in
      let refiner =
         try snd (dest_refiner (find_refiner refiner opname)) with
            Not_found ->
               eprintf "Warning: using default refiner for %s%t" name eflush;
               refiner
      in
         ShareSentinal (Refine.sentinal_of_refiner refiner)
   in
      ThreadRefiner.share (get_remote_server ()) "sentinal_object" lazy

let get_sentinal key =
   match ThreadRefiner.arg_of_key (get_remote_server ()) key with
      ShareSentinal sent ->
         sent
    | _ ->
         raise (Failure "Thread_refiner.get_sentinal")

(************************************************************************
 * CACHE                                                                *
 ************************************************************************)

(*
 * Cache function is lazy.
 *)
let make_cache f =
   ThreadRefiner.share (get_remote_server ()) "cache" (fun () -> ShareCache (ref (OutOfDate (f ()))))

(*
 * Caching.
 *)
let cache arg =
   match ThreadRefiner.arg_of_key (get_remote_server ()) arg.ref_cache with
      ShareCache cache ->
         begin
            match !cache with
               Current cache ->
                  cache
             | OutOfDate cache' ->
                  let cache' = Tactic_cache.set_msequent cache' arg.ref_goal in
                     cache := Current cache';
                     cache'
         end
    | _ ->
         raise (Failure "Tactic_type.cache")

let out_of_date key =
   match ThreadRefiner.arg_of_key (get_remote_server ()) key with
      ShareCache cache ->
         begin
            match !cache with
               Current cache' ->
                  cache := OutOfDate cache'
             | OutOfDate _ ->
                  ()
         end;
         key
    | _ ->
         raise (Failure "Tactic_type.out_of_date")

(************************************************************************
 * ATTRIBUTES                                                           *
 ************************************************************************)

(*
 * Lazy attribute generation.
 *)
let term_attribute name t =
   name, RawTermArg t

let type_attribute name t =
   name, RawTypeArg t

let int_attribute name i =
   name, RawIntArg i

let bool_attribute name b =
   name, RawBoolArg b

let subst_attribute name t =
   name, RawSubstArg t

let conv_attribute name f =
   name, RawObjectArg (ThreadRefiner.share (get_remote_server ()) name (fun () -> ShareConv (f ())))

let tactic_attribute name f =
   name, RawObjectArg (ThreadRefiner.share (get_remote_server ()) name (fun () -> ShareTactic (f ())))

let int_tactic_attribute name f =
   name, RawObjectArg (ThreadRefiner.share (get_remote_server ()) name (fun () -> ShareIntTactic (f ())))

let arg_tactic_attribute name f =
   name, RawObjectArg (ThreadRefiner.share (get_remote_server ()) name (fun () -> ShareArgTactic (f ())))

let tsubst_attribute name f =
   name, RawObjectArg (ThreadRefiner.share (get_remote_server ()) name (fun () -> ShareTSubst (f ())))

let typeinf_attribute name f =
   name, RawObjectArg (ThreadRefiner.share (get_remote_server ()) name (fun () -> ShareTypeinf (f ())))

(*
 * Collect all the simple attributes.
 *)
let attributes { ref_attributes = attributes } =
   let rec collect = function
      (name, hd) :: tl ->
         begin
            let tl = collect tl in
               match hd with
                  RawTermArg t ->
                     (name, TermArg t) :: tl
                | RawTypeArg t ->
                     (name, TypeArg t) :: tl
                | RawIntArg i ->
                     (name, IntArg i) :: tl
                | RawBoolArg b ->
                     (name, BoolArg b) :: tl
                | RawSubstArg t ->
                     (name, SubstArg t) :: tl
                | RawObjectArg _ ->
                     tl
         end
    | [] ->
         []
   in
      collect attributes

(*
 * Map a function over the terms in the attributes.
 *)
let rec map_attributes f = function
   [] ->
      []
 | (name, arg) :: tl ->
      let hd =
         match arg with
            TermArg t ->
               (name, TermArg (f t))
          | TypeArg t ->
               (name, TypeArg (f t))
          | IntArg i ->
               (name, IntArg i)
          | BoolArg b ->
               (name, BoolArg b)
          | SubstArg t ->
               (name, SubstArg (f t))
      in
         hd :: map_attributes f tl

(*
 * Fetch the attributes.
 *)
let get_term { ref_attributes = attributes } name =
   let rec search = function
      (name', RawTermArg t) :: tl ->
         if name' = name then
            t
         else
            search tl
    | _ :: tl ->
         search tl
    | [] ->
         raise (RefineError ("get_term", StringStringError ("not found", name)))
   in
      search attributes

let get_type { ref_attributes = attributes } name =
   let rec search = function
      (name', RawTypeArg t) :: tl ->
         if name' = name then
            t
         else
            search tl
    | _ :: tl ->
         search tl
    | [] ->
         raise (RefineError ("get_type", StringStringError ("not found", name)))
   in
      search attributes

let get_int { ref_attributes = attributes } name =
   let rec search = function
      (name', RawIntArg t) :: tl ->
         if name' = name then
            t
         else
            search tl
    | _ :: tl ->
         search tl
    | [] ->
         raise (RefineError ("get_int", StringStringError ("not found", name)))
   in
      search attributes

let get_bool { ref_attributes = attributes } name =
   let rec search = function
      (name', RawBoolArg t) :: tl ->
         if name' = name then
            t
         else
            search tl
    | _ :: tl ->
         search tl
    | [] ->
         raise (RefineError ("get_bool", StringStringError ("not found", name)))
   in
      search attributes

let get_conv { ref_attributes = attributes } name =
   let rec search = function
      (name', RawObjectArg key) :: tl ->
         if name' = name then
            match ThreadRefiner.arg_of_key (get_remote_server ()) key with
               ShareConv conv ->
                  conv
             | _ ->
                  search tl
         else
            search tl
    | _ :: tl ->
         search tl
    | [] ->
         raise (RefineError ("get_conv", StringStringError ("not found", name)))
   in
      search attributes

let get_tactic { ref_attributes = attributes } name =
   let rec search = function
      (name', RawObjectArg key) :: tl ->
         if name' = name then
            match ThreadRefiner.arg_of_key (get_remote_server ()) key with
               ShareTactic tac ->
                  tac
             | _ ->
                  search tl
         else
            search tl
    | _ :: tl ->
         search tl
    | [] ->
         raise (RefineError ("get_tactic", StringStringError ("not found", name)))
   in
      search attributes

let get_int_tactic { ref_attributes = attributes } name =
   let rec search = function
      (name', RawObjectArg key) :: tl ->
         if name' = name then
            match ThreadRefiner.arg_of_key (get_remote_server ()) key with
               ShareIntTactic tac ->
                  tac
             | _ ->
                  search tl
         else
            search tl
    | (name', _) :: tl ->
         search tl
    | [] ->
         raise (RefineError ("get_int_tactic", StringStringError ("not found", name)))
   in
      search attributes

let get_arg_tactic { ref_attributes = attributes } name =
   let rec search = function
      (name', RawObjectArg key) :: tl ->
         if name' = name then
            match ThreadRefiner.arg_of_key (get_remote_server ()) key with
               ShareArgTactic tac ->
                  tac
             | _ ->
                  search tl
         else
            search tl
    | (name', _) :: tl ->
         search tl
    | [] ->
         raise (RefineError ("get_int_tactic", StringStringError ("not found", name)))
   in
      search attributes

let get_tsubst { ref_attributes = attributes } name =
   let rec search = function
      (name', RawObjectArg key) :: tl ->
         if name' = name then
            match ThreadRefiner.arg_of_key (get_remote_server ()) key with
               ShareTSubst t ->
                  t
             | _ ->
                  search tl
         else
            search tl
    | _ :: tl ->
         search tl
    | [] ->
         raise (RefineError ("get_tsubst", StringStringError ("not found", name)))
   in
      search attributes

let get_typeinf { ref_attributes = attributes } name =
   let rec search = function
      (name', RawObjectArg key) :: tl ->
         if name' = name then
            match ThreadRefiner.arg_of_key (get_remote_server ()) key with
               ShareTypeinf t ->
                  t
             | _ ->
                  search tl
         else
            search tl
    | _ :: tl ->
         search tl
    | [] ->
         raise (RefineError ("get_typeinf", StringStringError ("not found", name)))
   in
      search attributes

let get_subst { ref_attributes = attributes } =
   let rec search = function
      (name, RawSubstArg t) :: tl ->
         (name, t) :: search tl
    | _ :: tl ->
         search tl
    | [] ->
         []
   in
      search attributes

(*
 * Two args are equal if their goals are equal.
 * Other arguments are ignored.
 *)
let tactic_arg_alpha_equal { ref_goal = goal1 } { ref_goal = goal2 } =
   msequent_alpha_equal goal1 goal2

(************************************************************************
 * REFINEMENT                                                           *
 ************************************************************************)

(*
 * The refiner just applies the tactic to the arg.
 * We keep a list of values
 *)
let refine_final_list = ref []

let add_final_hook f =
   refine_final_list := f :: !refine_final_list

let refine tac arg =
   refine_final_list := [];
   let x = ThreadRefinerAux.eval (get_remote_server ()) (tac arg) in
      List_util.rev_iter (fun f -> f ()) !refine_final_list;
      refine_final_list := [];
      x

(*
 * Eventually, we may want to look at the rule and do something
 * special here.
 *)
let compile_rule refiner tac =
   tac

(*
 * Utility for reconstructing the subgoals
 * in a tactic application.
 *)
let make_subgoal
    { ref_label = label;
      ref_attributes = attributes;
      ref_cache = cache;
      ref_sentinal = sentinal
    } goal =
   { ref_goal = goal;
     ref_label = label;
     ref_attributes = attributes;
     ref_cache = out_of_date cache;
     ref_sentinal = sentinal
   }

(*
 * Construct polymorphic tactic.
 *)
let tactic_of_rule rule (addrs, names) params arg =
   if !debug_tactic then begin
      eprintf "Collecting addresses%t" eflush;
      let rule = rule (addrs, names) params in
      eprintf "Starting refinement%t" eflush;
      let subgoals, ext = Refine.refine (get_sentinal arg.ref_sentinal) rule arg.ref_goal in
      eprintf "tactic_of_rule done%t" eflush;
      ThreadRefinerTacticals.create_value (List.map (make_subgoal arg) subgoals) (Extract (ext, List.length subgoals))
   end else
      let rule = rule (addrs, names) params in
      let subgoals, ext = Refine.refine (get_sentinal arg.ref_sentinal) rule arg.ref_goal in
      ThreadRefinerTacticals.create_value (List.map (make_subgoal arg) subgoals) (Extract (ext, List.length subgoals))

(*
 * Construct polymorphic tactic.
 *)
let tactic_of_refine_tactic rule arg =
   let _ =
      if !debug_tactic then
         eprintf "Starting refinement%t" eflush
   in
   let { ref_goal = goal; ref_sentinal = sentinal } = arg in
   let subgoals, ext = Refine.refine (get_sentinal sentinal) rule goal in
      if !debug_tactic then
         eprintf "tactic_of_rule done%t" eflush;
      List.map (make_subgoal arg) subgoals, Extract (ext, List.length subgoals)

(*
 * Convert a rewrite into a tactic.
 *)
let tactic_of_rewrite_exn1 = RefineError ("tactic_of_rewrite", StringError "rewrite did not produce a goal")
let tactic_of_rewrite_exn2 = RefineError ("tactic_of_rewrite", StringError "rewrite produced too many goals")

let tactic_of_rewrite rw arg =
   let rule = rwtactic rw in
   let { ref_goal = goal;
         ref_label = label;
         ref_attributes = attributes;
         ref_cache = cache;
         ref_sentinal = sentinal
       } = arg
   in
      match Refine.refine (get_sentinal sentinal) rule goal with
         [subgoal], ext ->
            let subgoal =
               { ref_goal = subgoal;
                 ref_label = label;
                 ref_attributes = attributes;
                 ref_cache = out_of_date cache;
                 ref_sentinal = sentinal
               }
            in
               ThreadRefinerTacticals.create_value [subgoal] (Extract (ext, 1))
       | [], _ ->
            raise tactic_of_rewrite_exn1
       | _ ->
            raise tactic_of_rewrite_exn2


(*
 * Convert a conditional rewrite to a tactic.
 *)
let tactic_of_cond_rewrite crw arg =
   let rule = crwtactic crw in
   let { ref_goal = goal;
         ref_label = label;
         ref_attributes = attributes;
         ref_cache = cache;
         ref_sentinal = sentinal
       } = arg
   in
   let subgoals, ext = Refine.refine (get_sentinal sentinal) rule goal in
   let make_subgoal goal =
      { ref_goal = goal;
        ref_label = label;
        ref_attributes = attributes;
        ref_cache = out_of_date cache;
        ref_sentinal = sentinal
      }
   in
      ThreadRefinerTacticals.create_value (List.map make_subgoal subgoals) (Extract (ext, List.length subgoals))

(************************************************************************
 * EXTRACTS                                                             *
 ************************************************************************)

(*
 * Compose two extracts.
 *)
let compose ext extl =
   Compose (ext, extl)

(*
 * Flatten the extract tree to produce a normal form.
 *)
let justify_exn = RefineError ("Tactic_type.justify", StringError "identity tactic failed")

let rec justify extl = function
   Compose (ext, extl') ->
      let rec justify_list extl = function
         ext' :: extl' ->
            let ext', extl = justify extl ext' in
            let extl', extl = justify_list extl extl' in
               ext' :: extl', extl
       | [] ->
            [], extl
      in
      let extl', extl = justify_list extl extl' in
      let ext, _ = justify extl' ext in
         Refine.compose ext extl', extl

 | Extract (ext, n) ->
      let extl, extl' = List_util.split_list n extl in
         Refine.compose ext extl, extl'

 | Identity ->
      match extl with
         ext :: extl ->
            ext, extl
       | [] ->
            raise justify_exn

(*
 * To produce a term from the extract, the proof must be complete.
 *)
let term_of_extract refiner ext args =
   let ext, _ = justify [] ext in
      Refine.term_of_extract refiner ext args

(************************************************************************
 * TACTICALS                                                            *
 ************************************************************************)

(*
 * Assumption tactic from the refiner.
 * Assumptions are numbered from 1, but
 * refiner numbers them from 0.
 *)
module X =
struct
   let tactic_of_refine_tactic = tactic_of_refine_tactic
end

let nthAssumT i p =
   let i = i - 1 in
      if !debug_refine then
         begin
            let { ref_goal = seq } = p in
            let goal, hyps = dest_msequent seq in
               eprintf "Tactic_type.nthAssumT:\nHyp: %d%t" i eflush;
               List.iter (fun hyp ->
                     print_term stderr hyp;
                     eflush stderr) hyps;
               eprintf "\nGoal: ";
               print_term stderr goal;
               eflush stderr
         end;
      let subgoals, ext = X.tactic_of_refine_tactic (Refine.nth_hyp i) p in
         ThreadRefinerTacticals.create_value subgoals ext

(*
 * Identity doesn't do anything.
 *)
let idT p =
   ThreadRefinerTacticals.create_value [p] Identity

(*
 * Sequencing tactics.
 *)
let prefix_thenT = ThreadRefinerTacticals.compose1
let prefix_thenLT = ThreadRefinerTacticals.compose2
let prefix_thenFLT = ThreadRefinerTacticals.composef
let firstT = ThreadRefinerTacticals.first
let prefix_orelseT tac1 tac2 =
   firstT [tac1; tac2]

(*
 * Modify the label.
 *)
let setLabelT name p =
   let { ref_goal = goal;
         ref_attributes = attributes;
         ref_cache = cache;
         ref_sentinal = sentinal
       } = p
   in
   let p =
      { ref_goal = goal;
        ref_label = name;
        ref_attributes = attributes;
        ref_cache = cache;
        ref_sentinal = sentinal
      }
   in
      ThreadRefinerTacticals.create_value [p] Identity

(*
 * Add a term argument.
 *)
let withT attribute tac p =
   let attributes = p.ref_attributes in
   let make_goal
       { ref_goal = goal;
         ref_label = name;
         ref_cache = cache;
         ref_sentinal = sentinal
       } =
      ThreadRefinerTacticals.create_value  (**)
         [{ ref_goal = goal;
            ref_label = name;
            ref_attributes = attribute :: attributes;
            ref_cache = cache;
            ref_sentinal = sentinal
          }] Identity
   in
   let make_subgoal p =
      let { ref_goal = goal;
            ref_label = name;
            ref_cache = cache;
            ref_sentinal = sentinal
          } = p
      in
         ThreadRefinerTacticals.create_value (**)
            [{ ref_goal = goal;
               ref_label = name;
               ref_attributes = attributes;
               ref_cache = cache;
               ref_sentinal = sentinal
             }]  Identity
   in
      (make_goal thenT tac thenT make_subgoal) p

let withTermT name t =
   withT (name, RawTermArg t)

let withTypeT name t =
   withT (name, RawTypeArg t)

let withIntT name i =
   withT (name, RawIntArg i)

let withBoolT name flag =
   withT (name, RawBoolArg flag)

let withTacticT name tac =
   raise (RefineError ("withTacticT", StringError "not implemented"))

(*
 * Add some substitutions.
 *)
let withSubstT subst tac arg =
   let attributes = arg.ref_attributes in
   let make_goal arg =
      let { ref_goal = goal;
            ref_label = name;
            ref_attributes = attributes;
            ref_cache = cache;
            ref_sentinal = sentinal
          } = arg
      in
      let rec make_subst = function
         (name, t) :: tl ->
            (name, RawSubstArg t) :: (make_subst tl)
       | [] ->
            attributes
      in
         ThreadRefinerTacticals.create_value (**)
            [{ ref_goal = goal;
               ref_label = name;
               ref_attributes = make_subst subst;
               ref_cache = cache;
               ref_sentinal = sentinal
             }] Identity
   in
   let make_subgoal arg =
      let { ref_goal = goal;
            ref_label = name;
            ref_cache = cache;
            ref_sentinal = sentinal
          } = arg
      in
         ThreadRefinerTacticals.create_value (**)
            [{ ref_goal = goal;
               ref_label = name;
               ref_attributes = attributes;
               ref_cache = cache;
               ref_sentinal = sentinal
             }] Identity
   in
      (make_goal thenT tac thenT make_subgoal) arg

(*
 * Time the tactic.
 * This shows the time between now and the end of refinement.
 *)
let finalT f p =
   add_final_hook f;
   idT p

let timingT tac p =
   let start = Unix.times () in
   let start_time = Unix.gettimeofday () in
   let finalize () =
      let finish = Unix.times () in
      let finish_time = Unix.gettimeofday () in
         eprintf "User time %f; System time %f; Real time %f%t" (**)
            ((finish.Unix.tms_utime +. finish.Unix.tms_cutime)
             -. (start.Unix.tms_utime +. start.Unix.tms_cstime))
            ((finish.Unix.tms_stime +. finish.Unix.tms_cstime)
             -. (start.Unix.tms_stime +. finish.Unix.tms_cstime))
            (finish_time -. start_time)
            eflush
   in
      add_final_hook finalize;
      tac p

(*
 * Try marshaling, used for making sure OCaml marshaler doesn't fold
 * too much into the function closures.
let check_marshal name f =
   eprintf "+ Tactic_type: marshaling %s%t" name eflush;
   try
      let _ = Appl_closure.marshal f in
         ()
   with
      Invalid_argument s ->
         eprintf "Tactic_type: marshaling fails on %s: %s%t" name s eflush

let test_marshal () =
   check_marshal "create" create;
   check_marshal "sentinal_of_refiner" sentinal_of_refiner;
   check_marshal "sentinal_of_refiner_object" sentinal_of_refiner_object;
   check_marshal "make_cache" make_cache;
   check_marshal "args" args;
   check_marshal "main_loop" main_loop;
   check_marshal "goal" goal;
   check_marshal "msequent" msequent;
   check_marshal "nth_hyp" nth_hyp;
   check_marshal "nth_concl" nth_concl;
   check_marshal "cache" cache;
   check_marshal "label" label;
   check_marshal "set_goal" set_goal;
   check_marshal "set_concl" set_concl;
   check_marshal "set_label" set_label;
   check_marshal "term_attribute" term_attribute;
   check_marshal "type_attribute" type_attribute;
   check_marshal "int_attribute" int_attribute;
   check_marshal "bool_attribute" bool_attribute;
   check_marshal "subst_attribute" subst_attribute;
   check_marshal "conv_attribute" conv_attribute;
   check_marshal "tactic_attribute" tactic_attribute;
   check_marshal "int_tactic_attribute" int_tactic_attribute;
   check_marshal "arg_tactic_attribute" arg_tactic_attribute;
   check_marshal "tsubst_attribute" tsubst_attribute;
   check_marshal "typeinf_attribute" typeinf_attribute;
   check_marshal "attributes" attributes;
   check_marshal "get_term" get_term;
   check_marshal "get_type" get_type;
   check_marshal "get_int" get_int;
   check_marshal "get_bool" get_bool;
   check_marshal "get_subst" get_subst;
   check_marshal "get_conv" get_conv;
   check_marshal "get_tactic" get_tactic;
   check_marshal "get_int_tactic" get_int_tactic;
   check_marshal "get_arg_tactic" get_arg_tactic;
   check_marshal "get_tsubst" get_tsubst;
   check_marshal "get_typeinf" get_typeinf;
   check_marshal "map_attributes" map_attributes;
   check_marshal "tactic_arg_alpha_equal" tactic_arg_alpha_equal;
   check_marshal "refine" refine;
   check_marshal "compose" compose;
   check_marshal "term_of_extract" term_of_extract;
   check_marshal "compile_rule" compile_rule;
   check_marshal "tactic_of_rule" tactic_of_rule;
   check_marshal "tactic_of_rewrite" tactic_of_rewrite;
   check_marshal "tactic_of_cond_rewrite" tactic_of_cond_rewrite;
   check_marshal "idT" idT;
   check_marshal "nthAssumT" nthAssumT;
   check_marshal "prefix_thenT" prefix_thenT;
   check_marshal "prefix_thenLT" prefix_thenLT;
   check_marshal "prefix_thenFLT" prefix_thenFLT;
   check_marshal "prefix_orelseT" prefix_orelseT;
   check_marshal "setLabelT" setLabelT;
   check_marshal "withTermT" withTermT;
   check_marshal "withTypeT" withTypeT;
   check_marshal "withBoolT" withBoolT;
   check_marshal "withIntT" withIntT;
   check_marshal "withSubstT" withSubstT;
   check_marshal "withTacticT" withTacticT;
   check_marshal "timingT" timingT;
   check_marshal "finalT" finalT
 *)

let test_marshal () =
   eprintf "Marshaler not linked%t" eflush

(*
 * -*-
 * Local Variables:
 * Caml-master: "refiner"
 * End:
 * -*-
 *)
